<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[manjaro安装后的一些问题与调整]]></title>
    <url>%2F2019%2F11%2F08%2F%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94%2Fmanjaro%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[安装manjaro过程中遇到的一些小问题的汇总与解决 1、使用U盘进行安装时无法进入桌面或安装时卡住 这是双显卡电脑独显问题需要禁用独显，U盘启动界面光标移至boot行按e编辑改成nouveau.modeset=0，但这只是临时禁用独显，安装成功后修改grub.cfg永久禁用 1$ sudo nano /boot/grub/grub.cfg 在文本中找到 quiet 在后面输入 xdriver=mesa acpi_osi=! acpi_osi=”windows 2009” 2、安装搜狗输入法 安装 fcitx 123$ sudo pacman -S fcitx-sogoupinyin$ sudo pacman -S fcitx-im$ sudo pacman -S fcitx-configtool 修改配置文件： 1$ sudo nano ~/.profile 在末尾添加一下语句： 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 安装后输入法后可能会出现异常无法使用,安装 fcitx-qt 1$ sudo pacman -S fcitx-qt 3、网易云音乐中无法输入中文 安装 qcef 1$ sudo pacman -S qcef 编辑修改 bash， 修改 LD_LIBRARY_PATH=/usr/lib 1$ sudo nano /opt/netease/netease-cloud-music/netease-cloud-music.bash 安装 vlc 1$ sudo pacman -S vlc 4、manjaro kde中deepin.com.qq.im无法启动Manjaro-kde桌面安装TIM/QQ的时候经常出现无法启动，其主要原因是deein-wine-tim打包了Gnome桌面部分内容，因此在KDE桌面环境下需要安装相应的Gnome桌面设置环境 安装gnome-settings-daemon 1sudo pacman -S gnome-settings-daemon 设置gnome-settings-daemon自启动 1sudo cp /etc/xdg/autostart/org.gnome.SettingsDaemon.XSettings.desktop ~/.config/autostart 如果不行就在/opt/deepinwine/apps/Deepin-QQ/run.sh开头添加 1/usr/lib/gsd-xsettings &amp; 5、teamviewer服务启动 启动 teamviewer 1sudo teamviewer --daemon start 停止 teamviewer 1sudo teamviewer --daemon stop]]></content>
      <categories>
        <category>问题随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>问题随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora极简教程]]></title>
    <url>%2F2019%2F06%2F29%2F%E6%97%A5%E5%B8%B8%2FTypora%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Typora download ” Markdown 是一种轻量级标记语言，创始人是约翰·格鲁伯（John Gruber）。它允许人们 “使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。” 1. 基本操作1.1 内容目录 语法 1[toc] 1.2 标题 语法 123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 1.3 引用 语法 123&gt; 引用内容1&gt; 引用内容2&gt;&gt; 引用内容3 效果 引用内容1引用内容2 引用内容3 2. 代码2.1 单行代码 语法 1`String str1 = &quot;hello&quot;;` 效果 String str1 = &quot;hello&quot;; 2.2 多行代码 语法 1234```~~~java​```c 效果 12int a = 10;int b = 20; 3. 列表3.1 无序列表 语法 123* 无序列表1+ 无序列表2- 无序列表3 效果 无序列表1 无序列表2 无序列表3 3.2 多行无序列表 语法 123* 多行无序列表1TAB * 多行无序列表2TAB TAB * 多行无序列表3 效果 多行无序列表1 多行无序列表2 多行无序列表3 3.3 有序列表 语法 1231\. 有序列表12\. 有序列表23\. 有序列表3 效果 有序列表1 有序列表2 有序列表3 3.4 多行有序列表 语法 12345671\. 多行有序列表12\. 多行有序列表2 1\. 多行有序列表2-1 2\. 多行有序列表2-23\. 多行有序列表3 1\. 多行有序列表3-1 2\. 多行有序列表3-2 效果 多行有序列表1 多行有序列表2 多行有序列表2-1 多行有序列表2-2 多行有序列表3 多行有序列表3-1 多行有序列表3-2 3.5 任务列表 语法 123-[ ] 抽烟-[x] 喝酒-[ ] 烫头 效果 -[ ] 抽烟-[x] 喝酒-[ ] 烫头 3.6 表格 语法 12345|姓名|性别|年龄|手机号||:---|:--:|:--:|---:||张三|男|21|18975346876||李四|女|23|17789548964||王五|男|25|15876513546| 效果 姓名 性别 年龄 手机号 张三 男 21 18975346876 李四 女 23 17789548964 王五 男 25 15876513546 4. 链接4.1 图片 语法1（本地图片） 1[图片上传失败...(image-61fd19-1520850984854)] 语法2（网络图片） 1![typora.jpg](https://upload-images.jianshu.io/upload_images/1538862-d91e815790b81e4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 效果2 4.2 超链接 语法1（行内式链接） 1[百度][https://www.baidu.com/] 效果1 [百度][https://www.baidu.com/] 语法2（参考式链接） 12[CSDN][CSDN网址][CSDN网址]:https://www.csdn.net/ 效果2 CSDN 语法3（自动链接） 1&lt;https://github.com/&gt; 效果2 https://github.com/ 5. 其他5.1 斜体 语法 12*斜体*_斜体_ 效果 斜体斜体 5.2 加粗 语法 12**加粗**__加粗__ 效果 加粗加粗 5.3 下划线 语法 1&lt;u&gt;下划线&lt;/u&gt; 效果 下划线 5.4 删除线 语法 1~~删除线~~ 效果 删除线 5.5 分隔线 语法 123***---___ 效果 5.6 注脚 语法 12Typora[^1][^1]A markdown editor 效果 Typora[1] 5.7 上下标 语法 1234$3^2=9$$3^&#123;(3-1)&#125;=9$$H_2SO_4$$H_&#123;2SO_4&#125;$ 效果 $3^2=9$$3^{(3-1)}=9$$H_2SO_4$ $H_{2SO_4}$ 5.8 符号的输入 语法 123456789101112\\ 反斜线\` 反引号\* 星号\_ 底线\&#123; \&#125; 花括号\[ \] 方括号\( \) 括弧\# 井字号\+ 加号\- 减号\. 英文句点\! 惊叹号 效果 \ ` * _ { } [ ] ( ) # + - . ! 5.9 特殊字符 语法 1234567891011121314151617181920&amp;copy; 版权 &amp;reg; 注册商标&amp;trade; 商标&amp;nbsp; 空格&amp;amp; 和号&amp;quot; 引号&amp;apos; 撇号&amp;lt; 小于号&amp;gt; 大于号&amp;ne; 不等号&amp;le; 小于等于&amp;ge; 大于等于&amp;cent; 分&amp;pound; 磅&amp;euro; 欧元&amp;yen; 元&amp;sect; 节&amp;times; 乘号&amp;divide; 除号&amp;plusmn; 正负号 效果 ©®™ &amp;“‘&lt; ≠≤≥¢£€¥§×÷± 附 HTML特殊字符编码对照表]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>问题解决</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中 sys.argv[]的用法简明解释]]></title>
    <url>%2F2019%2F01%2F05%2F%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94%2FPython%E4%B8%ADsys.argv%5B%5D%E7%9A%84%E7%94%A8%E6%B3%95%E7%AE%80%E6%98%8E%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[&nbsp; 因为是看书自学的python,开始后不久就遇到了这个引入的模块函数，且一直在IDLE上编辑了后运行，试图从结果发现它的用途，然而结果一直都是没结果，也在网上查了许多，但发现这个问题的比较详细的解释只有一个版本，大部分都是转载和复制的。给的都是简明python教程上那个一长串代码的例子，说看了就明白了，可我看得晕头转向的还是没真正明白，只知道“sys.argv[0]表示代码本身文件路径”这点，其实还是不明其意。后来经过大量努力，多方求教才真正明悟了，谨以记录和分享，希望能从另一个角度给同在求索过程中的同学一点启发。 sys.argv[]说白了就是一个从程序外部获取参数的桥梁，这个“外部”很关键，所以那些试图从代码来说明它作用的解释一直没看明白。因为我们从外部取得的参数可以是多个，所以获得的是一个列表（list)，也就是说sys.argv其实可以看作是一个列表，所以才能用[]提取其中的元素。其第一个元素是程序本身，随后才依次是外部给予的参数。 1、无参数下面我们通过一个极简单的test.py程序的运行结果来说明它的用法。 12345#test.py23 import sys4 a=sys.argv[0]5 print(a) 将test.py保存在c盘的根目录下。 在程序中找到 ‘运行’-&gt;点击-&gt;输入”cmd”-&gt;回车键 进入控制台命令窗口（如下图），先输入cd c:\ (作用是将命令路径改到c盘根目录)，然后输入test.py运行我们刚刚写的程序： 得到的结果是C:\test.py，这就是0指代码（即此.py程序）本身的意思。 2、一个参数然后我们将代码中0改为1 : 1a=sys.argv[1] 保存后，再从控制台窗口运行，这次我们加上一个参数，输入： 1# test.py what 得到的结果就是我们输入的参数what，看到这里你是不是开始明白了呢。 3、多个参那我们再把代码修改一下： 1a=sys.argv[2：] 保存后，再从控制台窗台运行程序，这次多加几个参数，以空格隔开: 1# test.py a b c d e f 得到的结果为[‘b’, ’c’, ’d’, ’e’, ’f’] 应该大彻大悟了吧。Sys.argv[ ]其实就是一个列表，里边的项为用户输入的参数，关键就是要明白这参数是从程序外部输入的，而非代码本身的什么地方，要想看到它的效果就应该将程序保存了，从外部来运行程序并给出参数。]]></content>
      <categories>
        <category>问题随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>问题解决</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2F2018%2F12%2F31%2F%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[原本文章写的是SSR教程，但因为SSR项目因为某些原因已经关闭，考虑到大部分用户的需求SS完全能够满足便将本教程修改为了SS，即Shadowsocks。 首先要购买国外主机，我个人推荐使用vlutr，价格和速度都比较理想，最近 vultr 2.5刀/月的vps部分地区缺货，其他的主机厂商大家也可以尝试，如搬瓦工(年付比较划算) 如果选择了vultr的话，请点击以下图片去注册(其实是我的推广链接(●’◡’●)) 下面以vultr为例讲解整个流程： 一、购买主机首先注册 然后充值，vultr从去年起支持支付宝支付，支付金额的话随意选，也可以自定义金额，最近好像有优惠：新用户不定时有优惠，以前新用户关注vultr推特是有三美元奖励的，这些大家可以自行了解。 充值完毕后我们点击右上角的那个加号来购买我们的VPS， 然后选择服务器位置、系统及配置 选64位的Debian8， 然后选择服务器配置，选最便宜的2.5美元/月，售罄的话就没办法了，换个位置，改买5刀/月的或者换别的商家吧，注意不要选择仅能使用ipv6的服务器，点击deploy now完成购买， 进入控制台就能看到我们刚买的服务器了，等几分钟后系统装完我们就点击进入详情页面查看， 记住ip地址、把密码复制下来 现在我们要做的就是连接到我们的服务器，现在我们需要一个ssh客户端，xshell，putty都是可以的，软件请自行通过网络下载，这里提供两篇教程以供参考：putty教程 xshell教程 请以root用户登录到服务器，我这里使用的是Ubuntu自带的ssh客户端 接下来就跟着下面的步骤安装SS 二、SS一键安装123# wget --no-check-certificate -O shadowsocks-go.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.sh# chmod +x shadowsocks-go.sh# ./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log 把上面的三行代码依次复制进终端然后回车，接着按照提示进行操作，可根据个人喜好设置密码和端口以及加密方式等等，也可以直接回车使用默认设置（这里使用的是秋水逸冰大佬的脚本） 设置密码。。。 设置端口 加密方式选默认直接回车 然后等待安装完成 安装完后会显示SSR的配置信息，一定要记下来哦 三、锐速优化锐速用于给服务器加速，可以跳过，试用之后感觉速度太慢再安装 锐速破解版安装，来自91云 PS：锐速不支持openvz的服务器，如果你购买的是搬瓦工，一定要注意选择kvm而不是openvz 脚本一： 1# wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh 备用脚本： 1# wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh 这里跟SS相同，只要把复制代码运行即可， 中间可能会让你选择内核版本及锐速版本根据提示选择即可 这样就算安装完了 安装完毕后就大功告成了，找到对应的客户端版本并安装，然后按照上面记下来的配置信息连接到你的SSR服务器就好了！ Shadowsocks Android版下载 Shadowsocks Windows版下载 iOS的就自己想办法吧╮(╯▽╰)╭，用wingy或者shadowrocket都是极好的 最后附一张YouTube 1080p 截图，祝大家翻墙愉快！]]></content>
      <categories>
        <category>问题随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 一. Ahead1.1 Install git(ubuntu)1$ sudo apt install git 1.2 Configuring git environmen12$ git config --global user.email “cwhong_top@163.com”$ git config --global user.name “cwhongtop” 1.3 New SSH Keys Check ssh keys 1$ less ~/.ssh/id_rsa.pub new ssh keys 1$ ssh-keygen -t rsa -C cwhong_top@163.com display ssh keys 1$ less ~/.ssh/id_rsa.pub Then add ssh keys to your github 在github首页右上角点击头像，选择Settings，然后选择New SSH KEY，把上面一步id_rsa.pub文件的秘钥复制进去就好了。 1.4 Configuring git environmen in hexo’s config.yml1234deploy:type: gitrepo: git@github.com:cwhongtop/cwhongtop.github.io.gitbranch: master 二. Quick Start2.1 Install hexo1$ npm install hexo -g 2.2 Create a new post1$ hexo new "My New Post" More info: Writing 2.3 Run server1$ hexo server More info: Server 2.4 Generate static files1$ hexo generate More info: Generating 2.5 Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Madonna pays tribute to Michael Jackson at the memorial service]]></title>
    <url>%2F2018%2F12%2F25%2F%E6%97%A5%E5%B8%B8%2FMadonnapaystributetoMichaelJacksonatthememorialservice%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、原文 Michael Jackson was born in August 1951 . So was I . Michael Jackson grew up in the suburbs of the Midwest . So did I . Michael Jackson had eight brothers and sisters . So do I . When Michael Jackson was six , he became a superstar , and was perhaps the world’s most beloved child . When I was six , my mother died . I think he got the shorter end of the stick . I never had a mother , but he never had a childhood . And when you never get to have something , you became obsessed by it . I spent my childhood searching for my mother’s figures , sometimes I was successful , but how do you recreate your childhood when you are under the magnifying glass of the world for your entire life . There is no question that Michael Jackson was one of the greatest talents the world has ever known . That when he sang a song at the ripe old age of eight he could make you feel like an experienced adult was squeezing your heart with his words . That when he moved he had the elegance of Fred Astaire and packed the punch of Muhammad Ali . That his music has an extra layer of inexplicable magic that did’t just make you want to dance but actually made you believe you could fly , dare to dream , be anything that you wanted to be . Because that is what heroes do and Michael Jackson was a hero . He performed in soccer stadiums around the world and sold hundreds of millions of records and dined with prime ministers and presidents . Girls fell in love with him , boys fell in love with him , everyone wanted to dance like him . He seemed otherworldly – but he was a human being . Like most performers he was shy and plagued with insecurities . I can’t say we were great friends , but in 1991 I decided I wanted to try to get to know him better . I asked him out to dinner , I said “My treat , I’ll drive – just you and me .” He agreed and showed up to my house without any bodyguards , we drove to the restaurant in my car . It was dark out , but he was still wearing sunglasses . I said , “Micheal , I feel like I’m talking to a limousine . Do you think you can take off your glasses so I can see your eyes ? ” He paused for a moment then he tossed the glasses out the window , looked at me with a wink and a smile and said , “Can you see me now ? Is that better ? ” In that moment , I could see both his vulnerability and his charm . The rest of the dinner , I was hellbent on getting him to eat French fries , drink wine , have dessert and say bad words . Things he never seemed to allow himself to do . Later we went back to my house to watch a movie and sat on the couch like two kids , and somewhere in the middle of the movie , his hand snuck over and held mine . It felt like he was looking for a friend more than a romance , and I was happy to oblige . In that moment , he did’t feel like a superstar . He felt like a human being . We went out a few more times together , and then for one reason or another we fell out of touch . Then the witch hunt began , and it seemed like one negative story after another was coming out about Michael . I felt his pain , I know what it’s like to walk down the street and feel like the whole world is turned against you . I know what it’s like to feel helpless and unable to defend yourself because the roar of lynch mob is so loud you feel like your voice can never be heard . But I had a childhood , and I was allowed to make mistakes and find my own way in the world without the glare of the spotlight . When I first heard that Michael had died , I was in London , days away from the start of my tour . Michael was going to perform in the same venue as me a week later . All I could think about in this moment was , “I had abandoned him .” That we had abandoned him . That we had allowed this magnificent creature who had once set the world on fire to somehow slip through the cracks . While he was trying to build a family and rebuild his career , we were all passing judgement . Most of us had turned our backs on him . In a desperate attempt to hold on his memory , I went on the Internet to watch old clips of his dancing and singing on TV and a stage and I thought , “my God , he was so unique , so original , so rare , and there will never be anyone like him again . He was a king . ” But he was also a human being , and also we were all human beings and sometimes we have to lose things before we can appreciate them . I want to end this on a positive note and say that to my sons , age nine and four , are obessed with Michael Jackson . There’s a whole lot of crotch grabbing and moon walking going on in my house . And , it seems like a whole new generation of kids have discovered his genius and are bringing him to life again . I hope that wherever Michael is right now he is smiling about this . Yes , Michael Jackson was a human being but he was a king . Long live the king . 二、译文： 迈克尔·杰克逊出生于1958年8月。我也是。迈克尔·杰克逊在美国中西部的郊区长大，我也是。迈克尔·杰克逊有八个兄弟姐妹，我也有。在迈克尔·杰克逊年仅6岁的时候，他便成为了一个超级巨星，或许更是世界上最受钟爱的小孩。而我6岁的时候，母亲永远离开了我。我认为他比我更不幸。我从没有拥有过母爱，而他却从来没有享受过童年。当一个人意识到永远得不到某种东西时，你就会对此念念不忘。我耗尽了童年寻找母亲的形象，；有时我成功了。但当你的一生都被放在放大镜下被人关注时，试问你如何重新找回你的童年？ 毫无疑问，迈克尔·杰克逊是世界上最伟大的天才之一……当他还是个8岁的小孩时，他的歌声已经让人感觉像个饱经沧桑的成人在述说他的故事，也因此扣人心弦……他舞动的方式，带着弗雷德·阿斯泰尔（Fred Astaire）的高雅，充满着拳王阿里（Muhammad Ali）的力量……他的音乐附着有一层无法解释魔力，令你不仅仅想随之而舞，更令你相信你可以飞翔，敢于梦想，成为任何你想成为的人。因为这就是英雄的影响力！而迈克尔·杰克逊就是个英雄！ 他在世界各地的体育场里表演，他卖出了上亿张唱片，他和总理首相总统共进晚餐。女孩爱上他，男孩爱上他，所有人都想像他一样舞蹈，他看上去就像来自另外一个世界，但他依然是一个普通人。就像大多数表演家一样，他害羞，苦恼着没有安全感。我无法说我们是很要好的朋友，但是在1991年，我决定我要更多地了解他。我邀请他出来共进晚餐：我说：“我请客，我开车，只有你和我。”他答应了，并只身一人不带保镖出现在我家中。我开车和他去餐馆，天已经很黑的可他仍然戴着他的墨镜。于是我说：“迈克尔，我觉得我是在跟这部车说话。你能把眼镜摘掉让我看见你的眼睛吗？”他犹豫了一会儿然后把眼镜扔出窗外，用闪烁的眼睛看着我，微笑着说：“现在你能看见我了没？有没有好点？” 在这时，我终于感受到他的脆弱和他的魅力。晚餐的其它部分，我则是努力要让他吃点炸薯条，喝点酒，享用点甜点，说点脏话，这些事情看上去是他永远不会允许自己去做的。之后，我们回到我的房子，看了部电影，我们坐在沙发上，就像两个孩子，就在电影放映中，他的手悄悄伸过来，握住了我的手。感觉上他是在寻找一个朋友，而不是寻找一份浪漫，我很高兴地遵从了他。在那个时刻，他感觉不像一个超级巨星，他就感觉是一个普通人。 我们后来又一起出去过好几次，但因为一些原因，我们失去了联络。然后，猎杀行动开始了，一个又一个负面故事纠缠着迈克尔。我可以体会他的痛苦。我很清楚当一个人走在街上而全世界似乎都与你为敌的感觉。我也很清楚那种无助和无法为自己辩护的痛苦，因为那些嘶吼着要将你处死的声音实在太大，以至于你确信无论如何，你的声音也不会有人听见。但我有过童年，我可以被允许去犯错误，然后在没有聚光灯闪耀的情况下，再在这个世界上找到属于我的路。 当我听到迈克尔去世的消息时，我正在伦敦，还有几天我就将在这里开始我的巡演。迈克尔也将于一周后在我表演的同一个场馆里开唱。而我当时的感觉便是我遗弃了他。我们都遗弃了他。我们曾让这个如此高贵壮美的生命，这个曾经让世界为之疯狂的生命，不知所以地被我们置之不理！当他试图建立自己的家庭和重拾他的事业时，我们都忙于对他做出评判。我们中的大部分人都对他背过身去。为拼命留住关于他的记忆，我上网，去看那些他在电视和舞台上唱歌跳舞的老片段，这时我想的是，“我的上帝，他是那么的独特，那么的原创，那么的罕见。再也不会有一个人和他一样了。”他就是国王。但他也是一个普通人，而，天啦，我们都是凡人，有时我们必须得等到失去以后，才能真正懂得去珍惜。 最后，我想以一个积极乐观的方式结束我的发言。我的两个儿子，一个9岁，一个4岁，都非常痴迷于迈克尔·杰克逊。他们成天都在家里跳月球漫步，抓着裤裆，就好像全世界新一代的小孩儿们都发现了他的天才，并要让他起死回生。我希望迈克尔现在无论身在何方，他都能为之微笑。 是的，迈克尔·杰克逊是一个凡人，但该死的，他还是一个国王！国王万岁！7]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csp-2014-12-02-Z字形扫描]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2Fcsp-2014-12-02Z%E5%AD%97%E5%BD%A2%E6%89%AB%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Program Description | 201412-2 || 试题名称： | Z字形扫描 || 时间限制： | 2.0s || 内存限制： | 256.0MB || 问题描述： |&nbsp;问题描述&nbsp; 在图像编码的算法中，需要将一个给定的方形矩阵进行Z字形扫描(Zigzag Scan)。给定一个n×n的矩阵，Z字形扫描的过程如下图所示：&nbsp; 对于下面的4×4的矩阵， 1 5 3 9 3 7 5 6 9 4 6 4 7 3 1 3 对其进行Z字形扫描后得到长度为16的序列： 1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3 请实现一个Z字形扫描的程序，给定一个n×n的矩阵，输出对这个矩阵进行Z字形扫描的结果。&nbsp;输入格式&nbsp; 输入的第一行包含一个整数n，表示矩阵的大小。 输入的第二行到第n+1行每行包含n个正整数，由空格分隔，表示给定的矩阵。&nbsp;输出格式&nbsp; 输出一行，包含n×n个整数，由空格分隔，表示输入的矩阵经过Z字形扫描后的结果。&nbsp;样例输入&nbsp;41 5 3 93 7 5 69 4 6 47 3 1 3&nbsp;样例输出&nbsp;1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3&nbsp;评测用例规模与约定&nbsp; 1≤n≤500，矩阵元素为不超过1000的正整数。 二、Solution 注：图中同一斜线上的点x与y坐标之和相同 三、Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/*****************************************Filename: MainAuthor: cwhongDate: 2018.05.25Description:csp2014-12-02,由图可知在同一斜线上行与列之和相同******************************************/#include&lt;iostream&gt;using namespace std;int map[501][501];int main()&#123; // 定义矩阵大小 int input_num; cin&gt;&gt;input_num; // 输入给定的矩阵 int i,j; for (i=1;i&lt;=input_num;i++) &#123; for (j=1;j&lt;=input_num;j++) &#123; cin&gt;&gt;map[i][j]; &#125; &#125; // 进行Z字形扫描 int t = 2; // 立一个标志，表示斜线的方向，0为右上左下，1则相反 int flag = 0; if (t == 2) &#123; cout&lt;&lt;map[1][1]&lt;&lt;&quot; &quot;; t++; &#125; for (t;t &lt;= 2 * input_num;t++) &#123; if (flag == 0) &#123; for (i=1;i&lt;t;i++) &#123; if (i &lt;= input_num &amp;&amp; t - i &lt;= input_num) &#123; cout&lt;&lt;map[i][t-i]&lt;&lt;&quot; &quot;; &#125; &#125; flag = 1; &#125; else if (flag == 1) &#123; for (i=1;i&lt;t;i++) &#123; if (i &lt;= input_num &amp;&amp; t - i &lt;= input_num) &#123; cout&lt;&lt;map[t-i][i]&lt;&lt;&quot; &quot;; &#125; &#125; flag = 0; &#125; &#125; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csp-2017-09-02-公共钥匙盒]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2Fcsp-2017-09-02%E5%85%AC%E5%85%B1%E9%92%A5%E5%8C%99%E7%9B%92%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description 试题编号： 201709-2试题名称： 公共钥匙盒时间限制： 1.0s内存限制： 256.0MB问题描述： 有一个学校的老师共用N个教室，按照规定，所有的钥匙都必须放在公共钥匙盒里，老师不能带钥匙回家。每次老师上课前，都从公共钥匙盒里找到自己上课的教室的钥匙去开门，上完课后，再将钥匙放回到钥匙盒中。 钥匙盒一共有N个挂钩，从左到右排成一排，用来挂N个教室的钥匙。一串钥匙没有固定的悬挂位置，但钥匙上有标识，所以老师们不会弄混钥匙。 每次取钥匙的时候，老师们都会找到自己所需要的钥匙将其取走，而不会移动其他钥匙。每次还钥匙的时候，还钥匙的老师会找到最左边的空的挂钩，将钥匙挂在这个挂钩上。如果有多位老师还钥匙，则他们按钥匙编号从小到大的顺序还。如果同一时刻既有老师还钥匙又有老师取钥匙，则老师们会先将钥匙全还回去再取出。 今天开始的时候钥匙是按编号从小到大的顺序放在钥匙盒里的。有K位老师要上课，给出每位老师所需要的钥匙、开始上课的时间和上课的时长，假设下课时间就是还钥匙时间，请问最终钥匙盒里面钥匙的顺序是怎样的？输入格式 输入的第一行包含两个整数N, K。 接下来K行，每行三个整数w, s, c，分别表示一位老师要使用的钥匙编号、开始上课的时间和上课的时长。可能有多位老师使用同一把钥匙，但是老师使用钥匙的时间不会重叠。 保证输入数据满足输入格式，你不用检查数据合法性。输出格式 输出一行，包含N个整数，相邻整数间用一个空格分隔，依次表示每个挂钩上挂的钥匙编号。样例输入5 24 3 32 2 7样例输出1 4 3 2 5样例说明 第一位老师从时刻3开始使用4号教室的钥匙，使用3单位时间，所以在时刻6还钥匙。第二位老师从时刻2开始使用钥匙，使用7单位时间，所以在时刻9还钥匙。 每个关键时刻后的钥匙状态如下（X表示空）： 时刻2后为1X345； 时刻3后为1X3X5； 时刻6后为143X5； 时刻9后为14325。样例输入5 71 1 143 3 121 15 122 7 203 18 124 21 195 30 9样例输出1 2 3 5 4评测用例规模与约定 对于30%的评测用例，1 ≤ N, K ≤ 10, 1 ≤ w ≤ N, 1 ≤ s, c ≤ 30； 对于60%的评测用例，1 ≤ N, K ≤ 50，1 ≤ w ≤ N，1 ≤ s ≤ 300，1 ≤ c ≤ 50； 对于所有评测用例，1 ≤ N, K ≤ 1000，1 ≤ w ≤ N，1 ≤ s ≤ 10000，1 ≤ c ≤ 100。 二、Solution 注：因为同一个老师一定是先借钥匙再还钥匙，所以借与还不存在矛盾，将所有老师借钥匙与还钥匙按时间排序，并且同时有多个老师还钥匙时按钥匙编号顺序排序，然后按序进行借与还的操作。本题中使用结构体，以及比较函数用sort进行排序操作。最终结果只得70分，有待后续改进。 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/*****************************************Filename: MainAuthor: cwhongDate: 2018.07.06Description:csp2017-09-2,公共钥匙盒******************************************/#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int key[1001];typedef struct Teacher&#123; // type 为0表示该老师是借，1则是还 int type; // time 表示老师借或者还钥匙的时间 int time; // key 表示该钥匙的编号 int key;&#125;t;t teacher[2002];bool Compare(t a,t b)&#123; // return a.time &lt; b.time; if (a.time &lt; b.time) &#123; // 首先按使用时间排序 return a.time &gt; b.time; &#125; else if (a.time == b.time) &#123; // 时间相同则还钥匙在前 if (a.type &lt; b.type) &#123; return true; &#125; else if (a.type == 1 &amp;&amp; b.type == 1) &#123; // 同时有多把钥匙要还则按钥匙编号从小到大顺序还 return a.key &gt; b.key; &#125; &#125;&#125;void KeyFunction(int key_num,int teacher_num)&#123; int i,j,k; for (i=teacher_num*2;i&gt;=1;i--) &#123; if (teacher[i].type == 0) &#123; for (j=1;j&lt;=key_num;j++) &#123; if (teacher[i].key == key[j]) &#123; key[j] = 0; break; &#125; &#125; &#125; else if (teacher[i].type == 1) &#123; for (j=1;j&lt;=key_num;j++) &#123; if (key[j] == 0) &#123; key[j] = teacher[i].key; break; &#125; &#125; &#125; &#125;&#125;main ()&#123; // 钥匙数量，老师数量 int key_num,teacher_num; cin&gt;&gt;key_num&gt;&gt;teacher_num; int i,j,k; for (i=1;i&lt;=key_num;i++) &#123; key[i] = i; &#125; int a,b,c; for (i=1;i&lt;=teacher_num;i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; teacher[i*2 - 1].type = 0; teacher[i*2 - 1].time = b; teacher[i*2 - 1].key = a; teacher[i*2].type = 1; teacher[i*2].time = b+c; teacher[i*2].key = a; &#125; // cout&lt;&lt;endl; // for (i=1;i&lt;=teacher_num*2;i++) // &#123; // cout&lt;&lt;teacher[i].type&lt;&lt;&quot; &quot;&lt;&lt;teacher[i].time&lt;&lt;&quot; &quot;&lt;&lt;teacher[i].key&lt;&lt;endl; // &#125; // cout&lt;&lt;endl; sort(teacher + 1,teacher + teacher_num*2 + 1,Compare); // for (i=1;i&lt;=teacher_num*2;i++) // &#123; // cout&lt;&lt;teacher[i].type&lt;&lt;&quot; &quot;&lt;&lt;teacher[i].time&lt;&lt;&quot; &quot;&lt;&lt;teacher[i].key&lt;&lt;endl; // &#125; // cout&lt;&lt;endl; KeyFunction(key_num,teacher_num); for (i=1;i&lt;=key_num;i++) &#123; cout&lt;&lt;key[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1003-Max-Sum]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1003-Max-Sum%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description Given a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14.&nbsp;InputThe first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000).&nbsp;OutputFor each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases.&nbsp;Sample Input2 5 6 -1 5 4 -7 7 0 6 -1 1 -6 7 -5&nbsp;Sample OutputCase 1: 14 1 4 Case 2:7 1 6 二、Solution 贪心问题，计算最大子序列，计算以每个节点为终点的最大子序列，若前一个节点最大子序列和为负则当前节点最大子序列和为其本身，否则当前节点加上前一节点的最大子序列和 三、Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * date:2017.11.18 * author:孟小德 * function:杭电acm1003 * Max Sum 贪心算法，计算每一个点做为终点的最大子序列和 */import java.util.*;public class acm1003&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int T = input.nextInt(); for (int i=0;i&lt;T;i++) &#123; int N = input.nextInt(); int[] num_N = new int[N]; // 输入数列 for (int j=0;j&lt;N;j++) &#123; num_N[j] = input.nextInt(); &#125; int[][] result = new int[N+1][3]; result[0][0] = num_N[0]; result[0][1] = 1; result[0][2] = 1; result[N][0] = num_N[0]; result[N][1] = 1; result[N][2] = 1; for (int j=1;j&lt;N;j++) &#123; if (result[j-1][0] &lt; 0) &#123; result[j][0] = num_N[j]; result[j][1] = j+1; result[j][2] = j+1; &#125; else &#123; result[j][0] = result[j-1][0] + num_N[j]; result[j][1] = result[j-1][1]; result[j][2] = j+1; &#125; if (result[N][0] &lt;= result[j][0]) &#123; result[N][0] = result[j][0]; result[N][1] = result[j][1]; result[N][2] = result[j][2]; &#125; &#125; System.out.println(&quot;Case &quot; + (i+1) + &quot;:&quot;); System.out.println(result[N][0] + &quot; &quot; +result[N][1] + &quot; &quot; + result[N][2]); if (i&lt;T-1) &#123; System.out.println(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1009-FatMouse'Trade]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1009-FatMouse'Trade%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain.&nbsp;InputThe input consists of multiple test cases. Each test case begins with a line containing two non-negative integers M and N. Then N lines follow, each contains two non-negative integers J[i] and F[i] respectively. The last test case is followed by two -1’s. All integers are not greater than 1000.&nbsp;OutputFor each test case, print in a single line a real number accurate up to 3 decimal places, which is the maximum amount of JavaBeans that FatMouse can obtain.&nbsp;Sample Input5 37 24 35 220 325 1824 1515 10-1 -1&nbsp;Sample Output13.33331.500 二、Solution 贪心问题，主要就是先排序 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * date:2017.11.14 * author:孟小德 * function:acm1099 * FatMouse&apos; Trade */ import java.util.*; import java.text.DecimalFormat; public class acm1009 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); DecimalFormat df = new DecimalFormat(&quot;0.000&quot;); int catf_num; int room_num; ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;(); while ((catf_num = input.nextInt()) != -1 &amp;&amp; (room_num = input.nextInt()) != -1) &#123; double[][] source = new double[room_num][2]; double[] persent = new double[room_num]; for (int i=0;i&lt;room_num;i++) &#123; source[i][0] = input.nextDouble(); source[i][1] = input.nextDouble(); persent[i] = source[i][0]/source[i][1]; &#125; sortArray(source,persent); double getNum = 0.0; for (int i=persent.length-1;i&gt;=0;i--) &#123; // int n = map.get(persent[i]); if (source[i][1] &lt;= catf_num) &#123; getNum += source[i][0]; catf_num -= source[i][1]; &#125; else &#123; getNum += catf_num * persent[i]; break; &#125; &#125; System.out.printf(&quot;%.3f&quot;,getNum); System.out.println(); &#125; &#125; //对输入的resource进行排序 public static void sortArray(int[][] source,double[] persent) &#123; boolean flag = true; Double temp; int[] tempArray = new int[2]; for (int i = 0;i&lt;persent.length &amp;&amp; flag;i++) &#123; flag = false; for (int j = 0;j&lt;persent.length-i-1;j++) &#123; if (persent[j] &gt; persent[j+1]) &#123; temp = persent[j]; persent[j] = persent[j+1]; persent[j+1] = temp; tempArray[0] = source[j][0]; tempArray[1] = source[j][1]; source[j][0] = source[j+1][0]; source[j][1] = source[j+1][1]; source[j+1][0] = tempArray[0]; source[j+1][1] = tempArray[1]; flag = true; &#125; &#125; &#125; &#125; static void sort(double[] a,double[][] c) &#123; int len = a.length; int low = 0,high = len - 1; quickSort(a,c, low, high); &#125; static void quickSort(double[] a, double[][] c,int l ,int h)&#123; if(l&gt;=h)&#123; return; &#125; int low = l; int high = h; double k = a[low]; double k2 = c[low][0]; double k3 = c[low][1]; while(low&lt; high)&#123; // while(high&gt;low&amp;&amp;a[high]&gt;=k)&#123;//寻找元素右边比其小的 high --; &#125; a[low] = a[high];//进行交换，K指向high c[low][0] = c[high][0]; c[low][1] = c[high][1]; while(low&lt;high&amp;&amp;a[low]&lt;=k)&#123;//寻找元素左边比其大的 low++; &#125; a[high] = a[low];//进行交换，K指向low c[high][0] = c[low][0]; c[high][1] = c[low][1]; &#125; a[low] = k;//将K赋给low c[low][0] = k2; c[low][1] = k3; quickSort(a, c,l, low-1); quickSort(a, c,low+1, h); &#125; &#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1010-Tempter-of-the-Bone]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1010-Tempter-of-the-Bone%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately to get out of this maze.&nbsp;The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him. &nbsp;InputThe input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 &lt; N, M &lt; 7; 0 &lt; T &lt; 50), which denote the sizes of the maze and the time at which the door will open, respectively. The next N lines give the maze layout, with each line containing M characters. A character is one of the following:&nbsp;‘X’: a block of wall, which the doggie cannot enter;‘S’: the start point of the doggie;‘D’: the Door; or‘.’: an empty block.&nbsp;The input is terminated with three 0’s. This test case is not to be processed. &nbsp;OutputFor each test case, print in one line “YES” if the doggie can survive, or “NO” otherwise. &nbsp;Sample Input4 4 5 S.X. ..X. ..XD …. 3 4 5 S.X. ..X. …D 0 0 0 &nbsp;Sample OutputNOYES 二、Solution 典型的深度搜索问题，使用dfs算法求解 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package acm1010;/** * date:2017.11.23 * author:孟小德 * function: 杭电acm1010 * Tempter of the Bone 深度搜索 bfs */import java.util.*;class Node&#123; int row,column; public Node(int row,int column) &#123; this.row = row; this.column = column; &#125; public Node() &#123; &#125;&#125;public class Main&#123; public static int n,m,T; public static boolean visit[][]; public static int dir[][] = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; public static boolean yes; public static Node start = new Node(); public static Node end = new Node(); public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); while (input.hasNextLine()) &#123; n = input.nextInt(); m = input.nextInt(); T = input.nextInt(); input.nextLine(); if (n == 0 &amp;&amp; m == 0 &amp;&amp; T == 0) &#123; break; &#125; visit = new boolean[n][m]; yes = false; int wall = 0; // 输入 for (int i=0;i&lt;n;i++) &#123; String str = input.nextLine(); for (int j=0;j&lt;m;j++) &#123; char c = str.charAt(j); switch(c) &#123; case &apos;X&apos;:visit[i][j] = true; wall++;break; case &apos;S&apos;:start = new Node(i,j);break; case &apos;D&apos;:end = new Node(i,j);break; case &apos;.&apos;:break; &#125; &#125; &#125; if (T&gt;n*m - wall - 1) &#123; System.out.println(&quot;NO&quot;); continue; &#125; visit[start.row][start.column] = true; dfs(start.row,start.column,0); if (yes) &#123; System.out.println(&quot;YES&quot;); &#125; else &#123; System.out.println(&quot;NO&quot;); &#125; &#125; &#125; public static void dfs(int row,int column,int time) &#123; for (int i=0;i&lt;dir.length;i++) &#123; int a = row + dir[i][0]; int b = column + dir[i][1];// 往各个方向搜索 int thetime = time + 1; if (thetime &gt;T) &#123; continue; &#125; if (a&lt;0 || a&gt;=n || b&lt;0 || b&gt;=m) &#123; // 越界 continue; &#125; if (visit[a][b] == true) &#123; // 被访问过 continue; &#125; if (a == end.row &amp;&amp; b == end.column) &#123; // 当访问到终点时 if (thetime == T) &#123; yes = true; return; &#125; else &#123; continue; &#125; &#125; // 每次递归都进行剪枝运算 int temp = T - thetime - Math.abs(a - end.row) - Math.abs(b - end.column); if (temp % 2 == 1) &#123; // 当剪枝结果为奇数时，在该点无法在指定时间到达终点 // 此时没必要在这点进行递归，当返回上层递归往另一个方向 // 继续 continue; &#125; visit[a][b] = true; dfs(a,b,thetime); // 同一个点在不同路径中可能被再次访问，因此 // 每一个路径中对应不同的visit visit[a][b] = false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1022-Train-Problem-I]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1022-Train-Problem-I%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description As the new term comes, the Ignatius Train Station is very busy nowadays. A lot of student want to get back to school by train(because the trains in the Ignatius Train Station is the fastest all over the world ^v^). But here comes a problem, there is only one railway where all the trains stop. So all the trains come in from one side and get out from the other side. For this problem, if train A gets into the railway first, and then train B gets into the railway before train A leaves, train A can’t leave until train B leaves. The pictures below figure out the problem. Now the problem for you is, there are at most 9 trains in the station, all the trains has an ID(numbered from 1 to n), the trains get into the railway in an order O1, your task is to determine whether the trains can get out in an order O2.&nbsp;Input&nbsp;The input contains several test cases. Each test case consists of an integer, the number of trains, and two strings, the order of the trains come in:O1, and the order of the trains leave:O2. The input is terminated by the end of file. More details in the Sample Input.&nbsp;Output&nbsp;The output contains a string “No.” if you can’t exchange O2 to O1, or you should output a line contains “Yes.”, and then output your way in exchanging the order(you should output “in” for a train getting into the railway, and “out” for a train getting out of the railway). Print a line contains “FINISH” after each test case. More details in the Sample Output.&nbsp;Sample Input&nbsp;3 123 321 3 123 312&nbsp;Sample Output&nbsp;Yes. in in in out out out FINISH No. FINISH&nbsp;Hint&nbsp;Hint&nbsp;For the first Sample Input, we let train 1 get in, then train 2 and train 3. So now train 3 is at the top of the railway, so train 3 can leave first, then train 2 and train 1. In the second Sample input, we should let train 3 leave first, so we have to let train 1 get in, then train 2 and train 3. Now we can let train 3 leave. But after that we can’t let train 1 leave before train 2, because train 2 is at the top of the railway at the moment.&nbsp;So we output “No.”. 二、Solution //栈和队列的使用 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/**date:2017.11.09*author:孟小德*function:蓝桥杯试题* 模拟栈*/import java.util.*;public class acm1022&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); ArrayList&lt;int[]&gt; resultList = new ArrayList&lt;int[]&gt;(); while (input.hasNextInt()) &#123; int num = input.nextInt(); String pushstring = input.next(); String popstring = input.next(); String[] pushStr = new String[num]; String[] popStr = new String[num]; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); int[] result = new int[2*num + 1]; //分割字符串 for (int i=0;i&lt;num;i++) &#123; pushStr[i] = pushstring.substring(i,i+1); popStr[i] = popstring.substring(i,i+1); &#125; result[0] = 1; int pop_index = 0; int push_index = 0; int j = 1; while (pop_index != num) &#123; if (stack.empty() == true &amp;&amp; push_index != num) &#123; stack.push(pushStr[push_index]); push_index++; result[j] = 1; j++; &#125; else if (stack.empty() == false &amp;&amp; push_index !=num) &#123; if (popStr[pop_index].equals(stack.peek())) &#123; stack.pop(); pop_index++; result[j] = -1; j++; &#125; else &#123; stack.push(pushStr[push_index]); push_index++; result[j] = 1; j++; &#125; &#125; else if (stack.empty() == false &amp;&amp; push_index ==num) &#123; if (popStr[pop_index].equals(stack.peek())) &#123; stack.pop(); pop_index++; result[j] = -1; j++; &#125; else &#123; result[0] = 0; break; &#125; &#125; else &#123; break; &#125; &#125; resultList.add(result); &#125; //输出结果 for (int k = 0;k&lt;resultList.size();k++) &#123; if (resultList.get(k)[0] == 1) &#123; System.out.println(&quot;Yes.&quot;); for (int i=1;i&lt;resultList.get(k).length;i++) &#123; if (resultList.get(k)[i] == 1) &#123; System.out.println(&quot;in&quot;); &#125; else &#123; System.out.println(&quot;out&quot;); &#125; &#125; &#125; else &#123; System.out.println(&quot;No.&quot;); &#125; System.out.println(&quot;FINISH&quot;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1026-Ignatius-and-the-Princess]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1026-Ignatius-and-the-Princess-I%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description The Princess has been abducted by the BEelzebub feng5166, our hero Ignatius has to rescue our pretty Princess. Now he gets into feng5166’s castle. The castle is a large labyrinth. To make the problem simply, we assume the labyrinth is a NM two-dimensional array which left-top corner is (0,0) and right-bottom corner is (N-1,M-1). Ignatius enters at (0,0), and the door to feng5166’s room is at (N-1,M-1), that is our target. There are some monsters in the castle, if Ignatius meet them, he has to kill them. Here is some rules:&nbsp;1.Ignatius can only move in four directions(up, down, left, right), one step per second. A step is defined as follow: if current position is (x,y), after a step, Ignatius can only stand on (x-1,y), (x+1,y), (x,y-1) or (x,y+1).2.The array is marked with some characters and numbers. We define them like this:. : The place where Ignatius can walk on.X : The place is a trap, Ignatius should not walk on it.n : Here is a monster with n HP(1&lt;=n&lt;=9), if Ignatius walk on it, it takes him n seconds to kill the monster.&nbsp;Your task is to give out the path which costs minimum seconds for Ignatius to reach target position. You may assume that the start position and the target position will never be a trap, and there will never be a monster at the start position.&nbsp;InputThe input contains several test cases. Each test case starts with a line contains two numbers N and M(2&lt;=N&lt;=100,2&lt;=M&lt;=100) which indicate the size of the labyrinth. Then a NM two-dimensional array follows, which describe the whole labyrinth. The input is terminated by the end of file. More details in the Sample Input.&nbsp;OutputFor each test case, you should output “God please help our poor hero.” if Ignatius can’t reach the target position, or you should output “It takes n seconds to reach the target position, let me show you the way.”(n is the minimum seconds), and tell our hero the whole path. Output a line contains “FINISH” after each test case. If there are more than one path, any one is OK in this problem. More details in the Sample Output.&nbsp;Sample Input5 6 .XX.1. ..X.2. 2…X. …XX. XXXXX. 5 6 .XX.1. ..X.2. 2…X. …XX. XXXXX1 5 6 .XX… ..XX1. 2…X. …XX. XXXXX.&nbsp;Sample OutputIt takes 13 seconds to reach the target position, let me show you the way. 1s:(0,0)-&gt;(1,0) 2s:(1,0)-&gt;(1,1) 3s:(1,1)-&gt;(2,1) 4s:(2,1)-&gt;(2,2) 5s:(2,2)-&gt;(2,3) 6s:(2,3)-&gt;(1,3) 7s:(1,3)-&gt;(1,4) 8s:FIGHT AT (1,4) 9s:FIGHT AT (1,4) 10s:(1,4)-&gt;(1,5) 11s:(1,5)-&gt;(2,5) 12s:(2,5)-&gt;(3,5) 13s:(3,5)-&gt;(4,5) FINISH It takes 14 seconds to reach the target position, let me show you the way. 1s:(0,0)-&gt;(1,0) 2s:(1,0)-&gt;(1,1) 3s:(1,1)-&gt;(2,1) 4s:(2,1)-&gt;(2,2) 5s:(2,2)-&gt;(2,3) 6s:(2,3)-&gt;(1,3) 7s:(1,3)-&gt;(1,4) 8s:FIGHT AT (1,4) 9s:FIGHT AT (1,4) 10s:(1,4)-&gt;(1,5) 11s:(1,5)-&gt;(2,5) 12s:(2,5)-&gt;(3,5) 13s:(3,5)-&gt;(4,5) 14s:FIGHT AT (4,5) FINISH God please help our poor hero.FINISH 二、Solution 这道题也是典型的深度搜索问题，要注意的就是在打印结果时从目标节点递归找到起点在依次在退出递归时打印每个节点的信息 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package acm1026;/** * date:2017.11.30; * author:孟小德 * function: 杭电acm1026 Ignatius and the Princess I * bfs 广度搜索 */import java.util.*;class Node implements Comparable&lt;Node&gt;&#123; public int x,y,step; public Node() &#123; &#125; public int compareTo(Node object) &#123; return this.step - object.step; &#125;&#125;public class Main&#123; // 四个方向 public static int[][] dir = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;; public static int map[][]; public static int flag[][]; public static int blood[][]; public static int n,m; public static int judge(int x,int y) &#123; if (x&lt;0 || x&gt;=n || y&lt;0 || y&gt;=m) &#123; return 1; &#125; if (map[x][y] == -1) &#123; return 1; &#125; return 0; &#125; public static int BFS() &#123; PriorityQueue&lt;Node&gt; queue = new PriorityQueue&lt;Node&gt;(); Node start = new Node(); Node next = new Node(); start.x = 0; start.y = 0; start.step = 0; map[0][0] = -1; queue.add(start); while(queue.isEmpty() == false) &#123; start = new Node(); start = queue.poll(); if (start.x == n-1 &amp;&amp; start.y == m-1) &#123; return start.step; &#125; for (int i=0;i&lt;4;i++) &#123; next = new Node(); next.x = start.x + dir[i][0]; next.y = start.y + dir[i][1]; if (judge(next.x,next.y) == 1) &#123; continue; &#125; next.step = start.step + 1 + map[next.x][next.y]; flag[next.x][next.y] = i+1; map[next.x][next.y] = -1; queue.add(next); &#125; &#125; return -1; &#125; public static int temp; public static void print(int x,int y) &#123; // 用递归方法顺序输出 // 外层递归为路径末尾 int next_x,next_y; if (flag[x][y] == 0) &#123; return; &#125; next_x = x - dir[flag[x][y] - 1][0]; next_y = y - dir[flag[x][y] - 1][1]; print(next_x,next_y); temp++; System.out.printf(&quot;%ds:(%d,%d)-&gt;(%d,%d)\n&quot;,temp,next_x,next_y,x,y); // 输出战斗过程 while (blood[x][y] &gt; 0) &#123; temp++; System.out.printf(&quot;%ds:FIGHT AT (%d,%d)\n&quot;,temp,x,y); blood[x][y]--; &#125; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); String str = new String(); int result; while (input.hasNextInt()) &#123; n = input.nextInt(); m = input.nextInt(); input.nextLine(); map = new int[n][m]; flag = new int[n][m]; blood = new int[n][m]; for (int i=0;i&lt;n;i++) &#123; str = input.nextLine(); for (int j=0;j&lt;m;j++) &#123; char c = str.charAt(j); if (c == &apos;.&apos;) &#123; map[i][j] = 0; &#125; else if (c == &apos;X&apos;) &#123; map[i][j] = -1; &#125; else &#123; map[i][j] = c - &apos;0&apos;; blood[i][j] = c - &apos;0&apos;; &#125; &#125; &#125; result = BFS(); if (result == -1) &#123; System.out.println(&quot;God please help our poor hero.&quot;); &#125; else &#123; System.out.printf(&quot;It takes %d seconds to reach the target position, let me show you the way.\n&quot;,result); temp = 0; print(n-1,m-1); &#125; System.out.println(&quot;FINISH&quot;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1052-田忌赛马]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1052-%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description Here is a famous story in Chinese history.&nbsp;“That was about 2300 years ago. General Tian Ji was a high official in the country Qi. He likes to play horse racing with the king and others.”&nbsp;“Both of Tian and the king have three horses in different classes, namely, regular, plus, and super. The rule is to have three rounds in a match; each of the horses must be used in one round. The winner of a single round takes two hundred silver dollars from the loser.”&nbsp;“Being the most powerful man in the country, the king has so nice horses that in each class his horse is better than Tian’s. As a result, each time the king takes six hundred silver dollars from Tian.”&nbsp;“Tian Ji was not happy about that, until he met Sun Bin, one of the most famous generals in Chinese history. Using a little trick due to Sun, Tian Ji brought home two hundred silver dollars and such a grace in the next match.”&nbsp;“It was a rather simple trick. Using his regular class horse race against the super class from the king, they will certainly lose that round. But then his plus beat the king’s regular, and his super beat the king’s plus. What a simple trick. And how do you think of Tian Ji, the high ranked official in China?”&nbsp;&nbsp;Were Tian Ji lives in nowadays, he will certainly laugh at himself. Even more, were he sitting in the ACM contest right now, he may discover that the horse racing problem can be simply viewed as finding the maximum matching in a bipartite graph. Draw Tian’s horses on one side, and the king’s horses on the other. Whenever one of Tian’s horses can beat one from the king, we draw an edge between them, meaning we wish to establish this pair. Then, the problem of winning as many rounds as possible is just to find the maximum matching in this graph. If there are ties, the problem becomes more complicated, he needs to assign weights 0, 1, or -1 to all the possible edges, and find a maximum weighted perfect matching…&nbsp;However, the horse racing problem is a very special case of bipartite matching. The graph is decided by the speed of the horses — a vertex of higher speed always beat a vertex of lower speed. In this case, the weighted bipartite matching algorithm is a too advanced tool to deal with the problem.&nbsp;In this problem, you are asked to write a program to solve this special case of matching problem.&nbsp;Input&nbsp;The input consists of up to 50 test cases. Each case starts with a positive integer n (n &lt;= 1000) on the first line, which is the number of horses on each side. The next n integers on the second line are the speeds of Tian’s horses. Then the next n integers on the third line are the speeds of the king’s horses. The input ends with a line that has a single 0 after the last test case.&nbsp;Output&nbsp;For each input case, output a line containing a single number, which is the maximum money Tian Ji will get, in silver dollars.&nbsp;Sample Input&nbsp;3 92 83 71 95 87 74 2 20 20 20 20 2 20 19 22 18 0&nbsp;Sample Output&nbsp;200 0 0 二、Solution 田忌赛马，首先用田忌最差的马和国王最差的马比较赢或输都赛一场，若平局则用田忌最好的马与国王最好的马比若赢则赛一场若输则用田忌最差的马与国王最好的赛一场，以这个顺序依次较量，得到最好的结果 三、Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * date:2017.11.15 * author:孟小德 * function:杭电acm1052 * 田忌赛马 */import java.util.*;public class acm1052&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int num; while((num = input.nextInt()) != 0) &#123; int[] tian = new int[num]; int[] king = new int[num]; for (int i=0;i&lt;num;i++) &#123; tian[i] = input.nextInt(); &#125; for (int i=0;i&lt;num;i++) &#123; king[i] = input.nextInt(); &#125; Arrays.sort(tian); Arrays.sort(king); int win = 0; int tian_h = tian.length-1; int tian_l = 0; int king_h = king.length-1; int king_l = 0; while (tian_l &lt;= tian_h) &#123; if (tian[tian_l] &gt; king[king_l]) &#123; win ++; tian_l++; king_l++; &#125; else if (tian[tian_l] &lt; king[king_l]) &#123; win--; tian_l++; king_h--; &#125; else &#123; if (tian[tian_h] &gt; king[king_h]) &#123; win++; tian_h--; king_h--; &#125; else &#123; if (tian[tian_l] &lt; king[king_h]) &#123; win--; &#125; tian_l++; king_h--; &#125; &#125; &#125; System.out.println(win * 200); &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1062-Text-Reverse]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1062-Text-Reverse%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description Ignatius likes to write words in reverse way. Given a single line of text which is written by Ignatius, you should reverse all the words and then output them.&nbsp;InputThe input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.Each test case contains a single line with several words. There will be at most 1000 characters in a line.&nbsp;OutputFor each test case, you should output the text which is processed.&nbsp;Sample Input3 olleh !dlrow m’I morf .udh I ekil .mca&nbsp;Sample Outputhello world! I’m from hdu. I like acm.HintRemember to use getchar() to read ‘\n’ after the interger T, then you may use gets() to read a line and process it. 二、Solution //简单的字符串处理 三、Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * date:2017.11.12 * author:孟小德 * function:acm试题1062 * Text Reverse 文本倒置 */import java.util.*;public class acm1062&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int num = input.nextInt(); input.nextLine(); String[] string = new String[num]; for (int i=0;i&lt;num;i++) &#123; string[i] = input.nextLine(); &#125; String[] result = new String[num]; for (int i=0;i&lt;num;i++) &#123; String[] str = string[i].split(&quot; &quot;); //分割字符串 result[i] = stringReverse(str[0]); for (int j = 1;j&lt;str.length;j++) &#123; result[i] = result[i] + &quot; &quot; + stringReverse(str[j]); &#125; //末尾空格加上 int n = string[i].length() - result[i].length(); for (int j = 0;j&lt;n;j++) &#123; result[i] += &quot; &quot;; &#125; &#125; for (int i = 0;i&lt;num;i++) &#123; System.out.println(result[i]); &#125; &#125; //翻转单词字母 public static String stringReverse(String str) &#123; if (str.equals(&quot;&quot;)) &#123; return &quot;&quot;; &#125; else &#123; String string = String.valueOf(str.charAt(str.length()-1)); for (int i=str.length()-2;i&gt;=0;i--) &#123; string += String.valueOf(str.charAt(i)); &#125; return string; &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1051-Wooden-Sticks]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1051-Wooden-Sticks%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description There is a pile of n wooden sticks. The length and weight of each stick are known in advance. The sticks are to be processed by a woodworking machine in one by one fashion. It needs some time, called setup time, for the machine to prepare processing a stick. The setup times are associated with cleaning operations and changing tools and shapes in the machine. The setup times of the woodworking machine are given as follows:&nbsp;(a) The setup time for the first wooden stick is 1 minute.(b) Right after processing a stick of length l and weight w , the machine will need no setup time for a stick of length l’ and weight w’ if l&lt;=l’ and w&lt;=w’. Otherwise, it will need 1 minute for setup.&nbsp;You are to find the minimum setup time to process a given pile of n wooden sticks. For example, if you have five sticks whose pairs of length and weight are (4,9), (5,2), (2,1), (3,5), and (1,4), then the minimum setup time should be 2 minutes since there is a sequence of pairs (1,4), (3,5), (4,9), (2,1), (5,2).&nbsp;InputThe input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case consists of two lines: The first line has an integer n , 1&lt;=n&lt;=5000, that represents the number of wooden sticks in the test case, and the second line contains n 2 positive integers l1, w1, l2, w2, …, ln, wn, each of magnitude at most 10000 , where li and wi are the length and weight of the i th wooden stick, respectively. The 2n integers are delimited by one or more spaces.&nbsp;OutputThe output should contain the minimum setup time in minutes, one per line.&nbsp;Sample Input3 5 4 9 5 2 2 1 3 5 1 4 3 2 2 1 1 2 2 3 1 3 2 2 3 1&nbsp;Sample Output2 1 3 二、Solution //贪心问题，先处理最长最重的木头以便一台机器可以处理尽可能多的木头， 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** * date:2017.11.15 * author:孟小德 * function:杭电acm1051 * */import java.util.*;public class acm1051&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int num = input.nextInt(); int[] result = new int[num]; for (int j=0;j&lt;num;j++) &#123; int wood_num = input.nextInt(); wood[] array = new wood[wood_num]; for (int i=0;i&lt;wood_num;i++) &#123; int len = input.nextInt(); int weight = input.nextInt(); array[i] = new wood(len,weight); &#125; sort(array); int use_num = 0; result[j] = 0; wood temp = new wood(); while (use_num &lt; wood_num) &#123; for (int i=0;i&lt;wood_num;i++) &#123; //寻找未处理木头中最长最重的一根 if(array[i].use == false) &#123; temp = array[i]; break; &#125; &#125; for (int i=0;i&lt;wood_num;i++) &#123;// 寻找可以被同时处理的木头 if (array[i].use == false &amp;&amp; array[i].len &lt;= temp.len &amp;&amp; array[i].weight &lt;= temp.weight) &#123; array[i].use = true; use_num++; temp = array[i]; &#125; &#125; result[j]++; &#125; &#125; for (int i=0;i&lt;result.length;i++) &#123; System.out.println(result[i]); &#125; &#125; //按长度排序，长度相同则按重量排序 public static void sort(wood[] array) &#123; boolean flag = true; wood temp = new wood(); for (int i = 0;i&lt;array.length &amp;&amp; flag;i++) &#123; flag = false; for (int j = 0;j&lt;array.length-i-1;j++) &#123; if (array[j].len &lt; array[j+1].len) &#123; temp.len = array[j].len; temp.weight = array[j].weight; array[j].len = array[j+1].len; array[j].weight = array[j+1].weight; array[j+1].len = temp.len; array[j+1].weight = temp.weight; flag = true; &#125; else if (array[j].len == array[j+1].len) &#123; if (array[j].weight &lt; array[j+1].weight) &#123; temp.len = array[j].len; temp.weight = array[j].weight; array[j].len = array[j+1].len; array[j].weight = array[j+1].weight; array[j+1].len = temp.len; array[j+1].weight = temp.weight; flag = true; &#125; &#125; &#125; &#125; &#125;&#125;class wood&#123; public int len; public int weight; public boolean use = false; public wood() &#123; &#125; public wood(int len,int weight) &#123; this.len = len; this.weight = weight; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1232-畅通工程]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1232-%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？&nbsp;Input测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。&nbsp;Output对每个测试用例，在1行里输出最少还需要建设的道路数目。&nbsp;Sample Input4 2 1 3 4 3 3 3 1 2 1 3 2 3 5 2 1 2 3 5 999 0 0&nbsp;Sample Output1 0 2998 二、Solution 这是一个最小生成树和并查集问题，先使用并查集处理随后在查看有多少未联通的城镇即有多少点的根结点为其本身 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * date:2017.11.20 * author:孟小德 * function:杭电acm1232 * 畅通工程 使用查并集方法 */import java.util.*;public class acm1232&#123; public static int[] father; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int N,M; int result; while (input.hasNextInt()) &#123; N = input.nextInt(); if (N == 0) &#123; break; &#125; M = input.nextInt(); father = new int[N+1]; for (int i=1;i&lt;N+1;i++) &#123; father[i] = i; &#125; for (int i=0;i&lt;M;i++) &#123; int a = input.nextInt(); int b = input.nextInt(); union(a,b); &#125; result = 0; //若该树是联通的，那么只有一个节点的父节点是其自身 for (int i=1;i&lt;N+1;i++) &#123; if (father[i] == i) &#123; result++; &#125; &#125; System.out.println(result - 1); &#125; &#125; public static void union(int m,int n) &#123; //合并集合 int a = getParent(m); int b = getParent(n); if (a!=b) &#123; father[a] = b; &#125; &#125; public static int getParent(int m) &#123; //寻找节点的根节点 while (father[m] != m) &#123; m = father[m]; &#125; return m; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1257-最少拦截系统]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description 某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.&nbsp;Input输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔) &nbsp;Output对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.&nbsp;Sample Input8 389 207 155 300 299 170 158 65&nbsp;Sample Output2 二、Solution //这道题其实并不复杂我之前写的时候想复杂了，后来看了同学代码才发现自己想复杂了，其实就是在拦截时能用已有的系统拦截就用已有的系统拦截，如果不能就新加一个系统，在有多个系统时从拦截高度最低的系统开始用 三、Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package acm1257;/** * date:2017.11.15 * author:孟小德 * function:杭电acm1257 * 最少拦截系统 */import java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int result; while (input.hasNext()) &#123; int num = input.nextInt(); int gd = input.nextInt(); // 导弹的高度 // 记录拦截系统 ArrayList&lt;Integer&gt; syslist = new ArrayList&lt;Integer&gt;(); syslist.add(gd); for (int i=1;i&lt;num;i++) &#123; gd = input.nextInt(); boolean flag = false; // 记录导弹是否被拦截 for (int j=0;j&lt;syslist.size();j++) &#123; if (gd &lt;= syslist.get(j)) &#123; syslist.set(j,gd); flag = true; break; &#125; &#125; if (flag == false) &#123; syslist.add(gd); &#125; Collections.sort(syslist); &#125; result = syslist.size(); System.out.println(result); &#125; input.close(); &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1272-小希的迷宫]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1272-%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description 上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。&nbsp;Input&nbsp;输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。整个文件以两个-1结尾。&nbsp;Output&nbsp;对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出”Yes”，否则输出”No”。&nbsp;Sample Input&nbsp;6 8 5 3 5 2 6 4 5 6 0 0 8 1 7 3 6 2 8 9 7 5 7 4 7 8 7 6 0 0 3 8 6 8 6 4 5 3 5 6 5 2 0 0 -1 -1&nbsp;Sample Output&nbsp;Yes Yes No 二、Solution 这是一个联通问题，即判断图是否联通，使用并查集将各点连接在连接过程中若两点有相同的根结点则不连接解决了回路问题，随后统计所有节点中有多少节点其根结点为其本身，若只有一个则所有节点已联通 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * date:2017.11.18 * author:孟小德 * function:杭电acm1272 * 小希的迷宫 使用完全的查并集方法 */import java.util.*;public class acm1272&#123; public static int[] father = new int[100005]; public static int[] visit = new int[100005]; public static boolean flag = true; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int m,n; int num; while (input.hasNextInt()) &#123; m = input.nextInt(); n = input.nextInt(); if (m == -1 &amp;&amp; n == -1) &#123; break; &#125; if (m == 0 &amp;&amp; n == 0) &#123; System.out.println(&quot;Yes&quot;); continue; &#125; //初始化father and visit for (int i=1;i&lt;100005;i++) &#123; father[i] = i; visit[i] = 0; &#125; visit[m] = 1; visit[n] = 1; flag = true; union(m,n); while (input.hasNextInt()) &#123; m = input.nextInt(); n = input.nextInt(); if (m == 0&amp;&amp;n == 0) &#123; break; &#125; visit[m] = 1; visit[n] = 1; union(m,n); &#125; num = 0; //若该树是联通的，那么只有一个节点的父节点是其自身 for (int i=1;i&lt;100005;i++) &#123; if (visit[i] == 1 &amp;&amp; father[i] == i) &#123; num++; &#125; if (num&gt;1) &#123; flag = false; &#125; &#125; if (flag == true) &#123; System.out.println(&quot;Yes&quot;); &#125; else &#123; System.out.println(&quot;No&quot;); &#125; &#125; &#125; public static void union(int m,int n) &#123; //合并集合 int a = getParent(m); int b = getParent(n); if (a!=b) &#123; father[a] = b; &#125; else &#123; flag = false; &#125; &#125; public static int getParent(int m) &#123; //寻找节点的根节点 while (father[m] != m) &#123; m = father[m]; &#125; return m; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1180-诡异的楼梯]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1180-%E8%AF%A1%E5%BC%82%E7%9A%84%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description Hogwarts正式开学以后,Harry发现在Hogwarts里,某些楼梯并不是静止不动的，相反,他们每隔一分钟就变动一次方向.比如下面的例子里,一开始楼梯在竖直方向,一分钟以后它移动到了水平方向,再过一分钟它又回到了竖直方向.Harry发现对他来说很难找到能使得他最快到达目的地的路线,这时Ron(Harry最好的朋友)告诉Harry正好有一个魔法道具可以帮助他寻找这样的路线,而那个魔法道具上的咒语,正是由你纂写的.&nbsp;Input&nbsp;测试数据有多组，每组的表述如下：第一行有两个数,M和N,接下来是一个M行N列的地图,’‘表示障碍物,’.’表示走廊,’|’或者’-‘表示一个楼梯,并且标明了它在一开始时所处的位置:’|’表示的楼梯在最开始是竖直方向,’-‘表示的楼梯在一开始是水平方向.地图中还有一个’S’是起点,’T’是目标,0&lt;=M,N&lt;=20,地图中不会出现两个相连的梯子.Harry每秒只能停留在’.’或’S’和’T’所标记的格子内.&nbsp;Output&nbsp;只有一行,包含一个数T,表示到达目标的最短时间.注意:Harry只能每次走到相邻的格子而不能斜走,每移动一次恰好为一分钟,并且Harry登上楼梯并经过楼梯到达对面的整个过程只需要一分钟,Harry从来不在楼梯上停留.并且每次楼梯都恰好在Harry移动完毕以后才改变方向.&nbsp;Sample Input&nbsp;5 5 *..T *.. ..|.. ... S….&nbsp;Sample Output&nbsp;7&nbsp;Hint&nbsp;Hint&nbsp;地图如下： 二、Solution 这是一个广度优先搜索问题 其中容易被忽略的一点就是当楼梯不可通过时可以在原地等一秒再通过 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package acm1180; /** * date:2017.12.7 * author:孟小德 * function: 杭电acm1180 * 诡异的楼梯 */import java.util.*;class Node&#123; int row,column,time; public Node(int row,int column,int time) &#123; this.row = row; this.column = column; this.time = time; &#125; public Node(int row,int column) &#123; this.row = row; this.column = column; &#125;&#125;public class Main&#123; public static int[][] map; public static boolean[][] visit; public static int M,N,time; public static Node S,T; public static int[][] dir = &#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;; // public static int flag; //记录前一次的方向 public static boolean crossBorder(int r,int c) &#123; if (r &lt; 1 || c &lt; 1 || r &gt; M || c &gt; N) &#123; return true; &#125; else if (map[r][c] == 0 || visit[r][c] == true) &#123; return true; &#125; return false; &#125; public static void BFS() &#123; Queue&lt;Node&gt; nodeQ = new LinkedList&lt;Node&gt;(); nodeQ.add(S); while (!nodeQ.isEmpty()) &#123; Node curNode = nodeQ.poll(); if ((curNode.row == T.row) &amp;&amp; (curNode.column == T.column)) &#123; if (curNode.time &lt; time) &#123; time = curNode.time; &#125; &#125; for (int i = 0;i&lt;4;i++) &#123; int r = curNode.row + dir[i][0]; int c = curNode.column + dir[i][1]; visit[curNode.row][curNode.column] = true; if (!crossBorder(r,c)) &#123; Node temp; if (map[r][c] == 1) &#123; temp = new Node(r,c,curNode.time+1); nodeQ.add(temp); &#125; else &#123; while ((curNode.time + i + map[r][c]) % 2 == 0) &#123; curNode.time++; &#125; r += dir[i][0]; c += dir[i][1]; if (!crossBorder(r,c)) &#123; temp = new Node(r,c,curNode.time+1); nodeQ.add(temp); &#125; curNode.time--; &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); while (input.hasNextInt()) &#123; M = input.nextInt(); //地图行 N = input.nextInt(); //地图列 map = new int[M+1][N+1]; //地图信息 visit = new boolean[M+1][N+1]; //节点是否访问过 input.nextLine(); // 输入 for (int i=0;i&lt;M;i++) &#123; String str = input.nextLine(); char c; for (int j=0;j&lt;N;j++) &#123; c = str.charAt(j); switch (c) &#123; case &apos;*&apos;: map[i+1][j+1] = 0; visit[i+1][j+1] = true; break; case &apos;.&apos;: map[i+1][j+1] = 1; visit[i+1][j+1] = false; break; case &apos;-&apos;: map[i+1][j+1] = -2; //时间加上此处的值对2取模， visit[i+1][j+1] = false; break; case &apos;|&apos;: map[i+1][j+1] = -1; //若值为1则楼梯竖，否则横 visit[i+1][j+1] = false; break; case &apos;S&apos;: map[i+1][j+1] = 1; visit[i+1][j+1] = false; S = new Node(i+1,j+1,0); break; case &apos;T&apos;: map[i+1][j+1] = 1; visit[i+1][j+1] = false; T = new Node(i+1,j+1); break; &#125; &#125; &#125; time = 100; BFS(); System.out.println(time); &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1597-find-the-nth-digit]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1597-find-the-nth-digit%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description 假设：S1 = 1S2 = 12S3 = 123S4 = 1234………S9 = 123456789S10 = 1234567891S11 = 12345678912…………S18 = 123456789123456789………………现在我们把所有的串连接起来S = 1121231234…….123456789123456789112345678912………那么你能告诉我在S串中的第N个数字是多少吗？ &nbsp;Input输入首先是一个数字K，代表有K次询问。接下来的K行每行有一个整数N(1 &lt;= N &lt; 2^31)。 &nbsp;Output对于每个N，输出S中第N个对应的数字. &nbsp;Sample Input6 1 2 3 4 5 10 &nbsp;Sample Output1 1 2 1 24 二、Solution 这道题可以用二分法解，但从数学角度来看这是一个等差数列问题通过数列求和公式 S = (n*(n+1))/2转换成二次方程可以求出所查的数在第几个数列 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142package acm1597;/** * date:2017.12.09 * author:孟小德 * function: 杭电acm1597 * find the nth digit */import java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int NUM_OF_INQUIRE = input.nextInt(); // 查询次数； double N_TH; // 查询第n个数 double STRING_LENGTH; // 串的长度 int RESULT; for (int i = 0;i&lt;NUM_OF_INQUIRE;i++) &#123; N_TH = input.nextDouble(); STRING_LENGTH = Math.ceil( (Math.sqrt(1 + 8*N_TH)-1)/2); N_TH -= (STRING_LENGTH * (STRING_LENGTH - 1))/2; RESULT = (int)(N_TH % 9); if (RESULT == 0) &#123; RESULT = 9; &#125; System.out.println(RESULT); &#125; input.close(); &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1548-A-string-lift]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1548-A-string-lift%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description There is a strange lift.The lift can stop can at every floor as you want, and there is a number Ki(0 &lt;= Ki &lt;= N) on every floor.The lift have just two buttons: up and down.When you at floor i,if you press the button “UP” , you will go up Ki floor,i.e,you will go to the i+Ki th floor,as the same, if you press the button “DOWN” , you will go down Ki floor,i.e,you will go to the i-Ki th floor. Of course, the lift can’t go up high than N,and can’t go down lower than 1. For example, there is a buliding with 5 floors, and k1 = 3, k2 = 3,k3 = 1,k4 = 2, k5 = 5.Begining from the 1 st floor,you can press the button “UP”, and you’ll go up to the 4 th floor,and if you press the button “DOWN”, the lift can’t do it, because it can’t go down to the -2 th floor,as you know ,the -2 th floor isn’t exist.Here comes the problem: when you are on floor A,and you want to go to floor B,how many times at least he has to press the button “UP” or “DOWN”? &nbsp;InputThe input consists of several test cases.,Each test case contains two lines.The first line contains three integers N ,A,B( 1 &lt;= N,A,B &lt;= 200) which describe above,The second line consist N integers k1,k2,….kn.A single 0 indicate the end of the input.&nbsp;OutputFor each case of the input output a interger, the least times you have to press the button when you on floor A,and you want to go to floor B.If you can’t reach floor B,printf “-1”. &nbsp;Sample Input5 1 5 3 3 1 2 5 0 &nbsp;Sample Output3 二、Solution 这道题用广度优先搜索来解，但是应当注意程序中不要出现死循环，队列中不重复添加已有的楼层 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package acm1548;/** * date:2017.12.08 * author:孟小德 * function: 杭电acm1548 * A strange lift */import java.util.*;class Node&#123; int floor,num,time; public Node(int floor,int num,int time) &#123; this.floor = floor; this.num = num; this.time = time; &#125; public Node() &#123;&#125;&#125;public class Main&#123; public static int N,A,B; public static int[] lift; //记录电梯每层信息 public static int[] inflag; public static void BFS() &#123; Node cur = new Node(A,lift[A],0); Queue&lt;Node&gt; nodeQ = new LinkedList&lt;Node&gt;(); nodeQ.add(cur); inflag[A] = 0; while (!nodeQ.isEmpty()) &#123; Node nfloor = nodeQ.poll(); if (nfloor.floor == B) &#123; System.out.println(nfloor.time); return; &#125; if (nfloor.time &gt; N - 1) &#123; System.out.println(-1); &#125; int x = nfloor.floor + nfloor.num; if (x&lt;=N &amp;&amp; inflag[x] == 0) &#123; inflag[x] = 1; nodeQ.add(new Node(x,lift[x],nfloor.time + 1)); &#125; x = nfloor.floor - nfloor.num; if (x&gt;=1 &amp;&amp; inflag[x] == 0) &#123; inflag[x] = 1; nodeQ.add(new Node(x,lift[x],nfloor.time + 1)); &#125; &#125; System.out.println(-1); &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); while ((N = input.nextInt()) != 0) &#123; A = input.nextInt(); B = input.nextInt(); lift = new int[N+1]; inflag = new int[N+1]; for (int i=1;i&lt;=N;i++) &#123; lift[i] = input.nextInt(); inflag[i] = 0; &#125; BFS(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1276-士兵队列训练问题]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1276-%E5%A3%AB%E5%85%B5%E9%98%9F%E5%88%97%E8%AE%AD%E7%BB%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description 某部队进行新兵队列训练，将新兵从一开始按顺序依次编号，并排成一行横队，训练的规则如下：从头开始一至二报数，凡报到二的出列，剩下的向小序号方向靠拢，再从头开始进行一至三报数，凡报到三的出列，剩下的向小序号方向靠拢，继续从头开始进行一至二报数。。。，以后从头开始轮流进行一至二报数、一至三报数直到剩下的人数不超过三人为止。&nbsp;Input本题有多个测试数据组，第一行为组数N，接着为N行新兵人数，新兵人数不超过5000。&nbsp;Output共有N行，分别对应输入的新兵人数，每行输出剩下的新兵最初的编号，编号之间有一个空格。&nbsp;Sample Input2 20 40&nbsp;Sample Output1 7 19 1 19 37 二、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * date:2017.11.10 * author:孟小德 * function:acm1276 * 士兵队列问题 */import java.util.*;public class acm1276&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int num = input.nextInt(); int[] list_size = new int[num]; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for (int i=0;i&lt;num;i++) &#123; list.add(new ArrayList&lt;Integer&gt;()); list_size[i] = input.nextInt(); &#125; for (int i=0;i&lt;num;i++) &#123; assignment(list.get(i),list_size[i]); // list_size[i] = input.nextInt(); ArrayList&lt;Integer&gt; delete_list = new ArrayList&lt;Integer&gt;(); while (list.get(i).size() &gt; 4) &#123; //士兵1 2 报数 number_off(list.get(i),delete_list,2); //士兵出列 if (delete_list.size() &gt; 0) &#123; delete(list.get(i),delete_list); &#125; delete_list.clear(); //士兵1 2 3 报数 if (list.get(i).size() &gt; 4) &#123; number_off(list.get(i),delete_list,3); &#125; else &#123; break; &#125; // 士兵出列 if (delete_list.size() &gt; 0) &#123; delete(list.get(i),delete_list); &#125; delete_list.clear(); &#125; &#125; for (int i=0;i&lt;num;i++) &#123; if (list.get(i).size() == 2) &#123; System.out.print(list.get(i).get(1)); &#125; else if (list.get(i).size() &gt; 2) &#123; System.out.print(list.get(i).get(1)); for (int j=2;j&lt;list.get(i).size();j++) &#123; System.out.print(&quot; &quot; + list.get(i).get(j)); &#125; &#125; System.out.println(); &#125; &#125; //给list列表赋值下标与值对应，第一个赋值为0 public static void assignment(ArrayList&lt;Integer&gt; list,int list_size) &#123; for (int i=0;i&lt;=list_size;i++) &#123; list.add(i); &#125; &#125; //士兵出列 public static void delete(ArrayList&lt;Integer&gt; list,ArrayList&lt;Integer&gt; delete_list) &#123; for (int i=delete_list.size()-1;i&gt;=0;i--) &#123; int n = delete_list.get(i); list.remove(n); // System.out.println(delete_list.get(i) + &quot; &quot; + list.size()); &#125; &#125; //士兵报数 public static void number_off(ArrayList&lt;Integer&gt; list, ArrayList&lt;Integer&gt; delete_list,int n) &#123; for (int i = 1;i&lt;list.size();i++) &#123; if (i%n == 0) &#123; delete_list.add(i); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1874-畅通工程续]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1874-%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description 某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。&nbsp;现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。&nbsp; Input&nbsp;本题目包含多组数据，请处理到文件结束。&nbsp;每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。&nbsp;接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。&nbsp;再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。&nbsp;Output&nbsp;对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.&nbsp;Sample Input&nbsp;3 3 0 1 1 0 2 3 1 2 1 0 2 3 1 0 1 1 1 2&nbsp;Sample Output&nbsp;2&nbsp;-1 二、Solution 这道题可以使用很多种方法来解dijkltra、floyd、最小生成树等，我这里选择的是dijkltra算法https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html&nbsp;当中需要注意的是两个城镇之间可能会有多条可通过的路径，因此在二维数组初始化时就应该选择最短的一条 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233package acm1874;/*** date:2017.12.17* author:孟小德* function:杭电acm1874* 畅通工程续 单源最短路径 迪杰斯特拉算法*/import java.util.*;public class Main&#123; public static int MAXINT = 200000000; //最大长度表示无法联通 public static int NUM_OF_NODE; //城镇的数量 public static int NUM_OF_EDGE; //道路的数量 public static int[] PATH; //记录到每个城镇的最短路径 public static int[][] MAP; //一个二维数组记录城镇的道路情况 public static boolean[] S; public static void dijkstra(int v0) &#123; for (int i=0;i&lt;NUM_OF_NODE;i++) &#123; PATH[i] = MAP[v0][i]; S[i] = false; &#125; PATH[v0] = 0; S[v0] = true; for (int i=1;i&lt;NUM_OF_NODE;i++) &#123; int minpath = MAXINT; int u = v0; for (int j=0;j&lt;NUM_OF_NODE;j++) &#123; if (S[j] == false &amp;&amp; PATH[j] &lt; minpath) &#123; u = j; minpath = PATH[j]; &#125; &#125; S[u] = true; //找到的当前点 // System.out.println(u); for (int j=0;j&lt;NUM_OF_NODE;j++) &#123; if (S[j] == false &amp;&amp; MAP[u][j] &lt; MAXINT) &#123;//通过当前点u找到其他点到v0的最短路径 // System.out.println(&quot;#&quot;); // System.out.println(u + &quot; &quot; + j); // System.out.println(PATH[j]); // System.out.println(PATH[u] + &quot; &quot; + MAP[u][j]); if (PATH[u] + MAP[u][j] &lt; PATH[j]) &#123; PATH[j] = PATH[u] + MAP[u][j]; //更新最短路径 &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); while (input.hasNextInt()) &#123; NUM_OF_NODE = input.nextInt(); NUM_OF_EDGE = input.nextInt(); MAP = new int[NUM_OF_NODE][NUM_OF_NODE]; PATH = new int[NUM_OF_NODE]; S = new boolean[NUM_OF_NODE]; for (int i=0;i&lt;NUM_OF_NODE;i++) &#123; // PATH[i] = MAXINT; // S[i] = false; for (int j=0;j&lt;NUM_OF_NODE;j++) &#123; MAP[i][j] = MAXINT; &#125; &#125; for (int i=0;i&lt;NUM_OF_EDGE;i++) &#123; int A = input.nextInt(); int B = input.nextInt(); int X = input.nextInt(); if (MAP[A][B] &gt; X) &#123; MAP[A][B] = X; MAP[B][A] = X; &#125; &#125; int v0 = input.nextInt(); int v = input.nextInt(); dijkstra(v0); if (PATH[v] == MAXINT) &#123; System.out.println(-1); &#125; else &#123; System.out.println(PATH[v]); &#125; &#125; input.close(); &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm2111-Saving-HDU]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm2111-Saving-HDU%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description 话说上回讲到海东集团面临内外交困，公司的元老也只剩下XHD夫妇二人了。显然，作为多年拼搏的商人，XHD不会坐以待毙的。 一天，当他正在苦思冥想解困良策的时候，突然想到了自己的传家宝，那是公司成立的时候，父亲作为贺礼送来的一个锦囊，徐父当时交代，不到万不得已的时候，不要打开它。“现在不正是最需要的时候吗？”，一边想，XHD一边找到了这个精心保管的锦囊，打开一看，里面只有一句话“杭城北麓千人洞有宝”。 二话不说，XHD拿起一个大口袋就出发了，这个千人洞他是知道的，小的时候，爸爸曾经带他来过这个隐蔽的路口，并告诉他，这是千人洞。他现在才明白爸爸当初这句话的含义。 尽管有点印象，XHD还是花了很大的精力才找到这个异常隐蔽的洞口，走进一看，几乎惊呆了，真的是眼花缭乱！不过尽管宝贝的种类不少，但是每种宝贝的量并不多，当然，每种宝贝单位体积的价格也不一样，为了挽救HDU，现在请你帮忙尽快计算出来XHD最多能带回多少价值的宝贝？（假设宝贝可以分割，分割后的价值和对应的体积成正比）&nbsp;Input输入包含多个测试实例，每个实例的第一行是两个整数v和n(v,n&lt;100)，分别表示口袋的容量和宝贝的种类，接着的n行每行包含2个整数pi和mi(0&lt;pi,mi&lt;10)，分别表示某种宝贝的单价和对应的体积，v为0的时候结束输入。&nbsp;Output对于每个测试实例，请输出XHD最多能取回多少价值的宝贝，每个实例的输出占一行。 &nbsp;Sample Input2 2 3 1 2 3 0&nbsp;Sample Output5 经过锦囊相助，HDU会脱离危机吗？ 欲知后事如何，且听下回分解—— 二、Solution //一个贪心问题，尽量拿单位价值高的宝物带走 三、Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * date:2017.11.16 * author:孟小德 * function:杭电acm2111 * Saving HDU */import java.util.*;public class acm2111&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int v; while ((v = input.nextInt()) != 0) &#123; int n = input.nextInt(); int[][] rea = new int[n][2]; // 输入宝物的信息 for (int i=0;i&lt;n;i++) &#123; rea[i][0] = input.nextInt(); rea[i][1] = input.nextInt(); &#125; sort(rea); int value = 0; for (int i=0;i&lt;rea.length;i++) &#123; if (v &gt;= rea[i][1]) &#123; value += rea[i][0] * rea[i][1]; v -= rea[i][1]; &#125; else &#123; value += rea[i][0] * v; break; &#125; &#125; System.out.println(value); &#125; &#125; // 按宝物单价由高到低排列 public static void sort(int[][] rea) &#123; boolean flag = true; int[] temp = new int[2]; for (int i = 0;i&lt;rea.length &amp;&amp; flag;i++) &#123; flag = false; for (int j = 0;j&lt;rea.length-i-1;j++) &#123; if (rea[j][0] &lt; rea[j+1][0]) &#123; temp[0] = rea[j][0]; temp[1] = rea[j][1]; rea[j][0] = rea[j+1][0]; rea[j][1] = rea[j+1][1]; rea[j+1][0] = temp[0]; rea[j+1][1] = temp[1]; flag = true; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1789-Dong-Homework-again]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1789-Dong-Homework-again%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description Ignatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test. And now we assume that doing everyone homework always takes one day. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.&nbsp;InputThe input contains several test cases. The first line of the input is a single integer T that is the number of test cases. T test cases follow.Each test case start with a positive integer N(1&lt;=N&lt;=1000) which indicate the number of homework.. Then 2 lines follow. The first line contains N integers that indicate the deadlines of the subjects, and the next line contains N integers that indicate the reduced scores.&nbsp;OutputFor each test case, you should output the smallest total reduced score, one line per test case.&nbsp;Sample Input3 3 3 3 3 10 5 1 3 1 3 1 6 2 3 7 1 4 6 4 2 4 3 3 2 1 7 6 5 4&nbsp;Sample Output0 35 二、Solution 这是一个贪心问题，首先将作业按扣分大小从大到小排序先作扣分大的作业，然后从作业截止日期向前寻找空闲时间做作业 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * date:2017.11.21 * author:孟小德 * function:杭电acm1789 * Doing Homework again 贪心算法 */import java.util.*;public class acm1789&#123; public static int[] date = new int[366]; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int num = input.nextInt(); boolean flag = false; for (int i=0;i&lt;num;i++) &#123; for (int j=0;j&lt;366;j++) &#123; date[j] = 0; &#125; int N = input.nextInt(); int[][] work = new int[N][2]; int result = 0; // 输入作业截止时间 for (int j=0;j&lt;N;j++) &#123; work[j][0] = input.nextInt(); &#125; // 输入作业未做扣分数 for (int j=0;j&lt;N;j++) &#123; work[j][1] = input.nextInt(); &#125; sort(work); for (int j=0;j&lt;N;j++) &#123; flag = false; for (int k=work[j][0];k&gt;0;k--) &#123; if (date[k] == 0) &#123; date[k] = 1; flag = true; break; &#125; &#125; if (flag == false) &#123; result += work[j][1]; &#125; &#125; System.out.println(result); &#125; &#125; // 由扣分多少从大到小排序 public static void sort(int[][] work) &#123; boolean flag = true; int[] temp = new int[2]; for (int i = 0;i&lt;work.length &amp;&amp; flag;i++) &#123; flag = false; for (int j = 0;j&lt;work.length-i-1;j++) &#123; if (work[j][1] &lt; work[j+1][1]) &#123; temp[0] = work[j][0]; temp[1] = work[j][1]; work[j][0] = work[j+1][0]; work[j][1] = work[j+1][1]; work[j+1][0] = temp[0]; work[j+1][1] = temp[1]; flag = true; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm1863-畅通工程]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm1863-%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description 省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。&nbsp;Input&nbsp;测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。&nbsp;Output&nbsp;对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。&nbsp;Sample Input&nbsp;3 3 1 2 1 1 3 2 2 3 4 1 3 2 3 2 0 100&nbsp;Sample Output&nbsp;3&nbsp;? 二、Solution 这道题用最小生成树和查并集来解，并查集https://baike.baidu.com/item/%E5%B9%B6%E6%9F%A5%E9%9B%86/9388442?fr=aladdin百度百科中有源代码 使用并查集生成树后若其中有不联通的点那么有两个以上的点父节点为其自身 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package acm1863;/** * date:2017.12.12 * author:孟小德 * function: 杭电acm1863 * 畅通工程 并查集，最小生成树 */import java.util.*;class Edge implements Comparable&lt;Edge&gt;&#123; public int start,end,cost; public Edge(int start,int end,int cost) &#123; this.start = start; this.end = end; this.cost = cost; &#125; public Edge() &#123; &#125; public int compareTo(Edge otherEdge) &#123; return this.cost - otherEdge.cost; &#125;&#125;public class Main&#123; public static int NUM_OF_NODE,NUM_OF_EDGE,RESULT; public static ArrayList&lt;Edge&gt; LIST_OF_EDGE = new ArrayList&lt;Edge&gt;(); public static int[] father; public static int getParent(int m) &#123; // 寻找节点的根 while(father[m] != m) &#123; m = father[m]; &#125; return m; &#125; public static int union(int x,int y,int c) &#123; // 找到两个节点的根若根相同则两节点已联通 // 否则未联通，将节点链接 int a = getParent(x); int b = getParent(y); if (a != b) &#123; father[a] = b; return c; &#125; return 0; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); while ((NUM_OF_EDGE = input.nextInt()) != 0) &#123; NUM_OF_NODE = input.nextInt(); father = new int[NUM_OF_NODE + 1]; for (int i=1;i&lt;=NUM_OF_NODE;i++) &#123; // 初始化根数组，每个节点初始根都是其本身 father[i] = i; &#125; for (int i=0;i&lt;NUM_OF_EDGE;i++) &#123; int s = input.nextInt(); int e = input.nextInt(); int c = input.nextInt(); LIST_OF_EDGE.add(new Edge(s,e,c)); &#125; Collections.sort(LIST_OF_EDGE);//对边进行排序 RESULT = 0; for (int i=0;i&lt;NUM_OF_EDGE;i++) &#123; int CUR_S = LIST_OF_EDGE.get(i).start; int CUR_E = LIST_OF_EDGE.get(i).end; int CUR_C = LIST_OF_EDGE.get(i).cost; RESULT += union(CUR_S,CUR_E,CUR_C); &#125; int num = 0; for (int i=1;i&lt;=NUM_OF_NODE;i++) &#123; if (father[i] == i) &#123; num++; &#125; &#125; if (num &gt; 1) &#123; System.out.println(&quot;?&quot;); &#125; else &#123; System.out.println(RESULT); &#125; LIST_OF_EDGE.clear(); &#125; input.close(); &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm2124-Repair-the-Wall]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm2124-Repair-the-Wall%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description Long time ago , Kitty lived in a small village. The air was fresh and the scenery was very beautiful. The only thing that troubled her is the typhoon.&nbsp;When the typhoon came, everything is terrible. It kept blowing and raining for a long time. And what made the situation worse was that all of Kitty’s walls were made of wood.&nbsp;One day, Kitty found that there was a crack in the wall. The shape of the crack isa rectangle with the size of 1×L (in inch). Luckly Kitty got N blocks and a saw(锯子) from her neighbors.The shape of the blocks were rectangle too, and the width of all blocks were 1 inch. So, with the help of saw, Kitty could cut down some of the blocks(of course she could use it directly without cutting) and put them in the crack, and the wall may be repaired perfectly, without any gap.&nbsp;Now, Kitty knew the size of each blocks, and wanted to use as fewer as possible of the blocks to repair the wall, could you help her ?&nbsp;InputThe problem contains many test cases, please process to the end of file( EOF ).Each test case contains two lines.In the first line, there are two integers L(0&lt;L&lt;1000000000) and N(0&lt;=N&lt;600) whichmentioned above.In the second line, there are N positive integers. The ith integer Ai(0&lt;Ai&lt;1000000000 ) means that the ith block has the size of 1×Ai (in inch).&nbsp;OutputFor each test case , print an integer which represents the minimal number of blocks are needed.If Kitty could not repair the wall, just print “impossible” instead.&nbsp;Sample Input5 3 3 2 1 5 2 2 1&nbsp;Sample Output2impossible 二、Solution 贪心问题，一块木板尽量多用几次，最后用的总木块数尽量少，所以先将裂缝安小到大排序 三、Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * date:2017.11.16 * author:孟小德 * function:杭电acm2124 * Repair the Wall 贪心算法，先最木块进行排序，最大最长的先处理 */ import java.util.*; public class acm2124 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); while (input.hasNextInt()) &#123; int L = input.nextInt(); int N = input.nextInt(); // 输入木块长度 int[] wood = new int[N]; for (int i=0;i&lt;N;i++) &#123; wood[i] = input.nextInt(); &#125; sort(wood); int len = 0; int num = 0; for (int i=0;i&lt;N;i++) &#123; if ((len + wood[i]) &lt; L) &#123; len += wood[i]; num++; &#125; else &#123; len += wood[i]; num++; break; &#125; &#125; if (len &gt;= L) &#123; System.out.println(num); &#125; else &#123; System.out.println(&quot;impossible&quot;); &#125; &#125; &#125; // 木块长度由大到小排列 public static void sort(int[] wood) &#123; boolean flag = true; int temp; for (int i = 0;i&lt;wood.length &amp;&amp; flag;i++) &#123; flag = false; for (int j = 0;j&lt;wood.length-i-1;j++) &#123; if (wood[j] &lt; wood[j+1]) &#123; temp = wood[j]; wood[j] = wood[j+1]; wood[j+1] = temp; flag = true; &#125; &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ (笔记) 浅析vector容器的实例]]></title>
    <url>%2F2018%2F12%2F25%2F%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94%2FC%2B%2B%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89%E6%B5%85%E6%9E%90vector%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、什么是vector 向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 二、容器特性1.顺序序列 顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。 2.动态数组 支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。 3.能够感知内存分配器的（Allocator-aware） 容器使用一个内存分配器对象来动态地处理它的存储需求。 二、基本函数实现1.构造函数 vector():创建一个空vector vector(int nSize):创建一个vector,元素个数为nSize vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t vector(const vector&amp;):复制构造函数 vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中 2.增加函数 void push_back(const T&amp; x):向量尾部增加一个元素X iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据 3.删除函数 iterator erase(iterator it):删除向量中迭代器指向元素 iterator erase(iterator first,iterator last):删除向量中[first,last)中元素 void pop_back():删除向量中最后一个元素 void clear():清空向量中所有元素 4.遍历函数 reference at(int pos):返回pos位置元素的引用 reference front():返回首元素的引用 reference back():返回尾元素的引用 iterator begin():返回向量头指针，指向第一个元素 iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置 reverse_iterator rbegin():反向迭代器，指向最后一个元素 reverse_iterator rend():反向迭代器，指向第一个元素之前的位置 5.判断函数 bool empty() const:判断向量是否为空，若为空，则向量中无元素 6.大小函数 int size() const:返回向量中元素的个数 int capacity() const:返回当前向量张红所能容纳的最大元素值 int max_size() const:返回最大可允许的vector元素数量值 7.其他函数 void swap(vector&amp;):交换两个同类型向量的数据 void assign(int n,const T&amp; x):设置向量中第n个元素的值为x void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素 8.看着清楚 1.push_back 在数组的最后添加一个数据2.pop_back 去掉数组的最后一个数据3.at 得到编号位置的数据4.begin 得到数组头的指针5.end 得到数组的最后一个单元+1的指针6．front 得到数组头的引用7.back 得到数组的最后一个单元的引用8.max_size 得到vector最大可以是多大9.capacity 当前vector分配的大小10.size 当前使用数据的大小11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值12.reserve 改变当前vecotr所分配空间的大小13.erase 删除指针指向的数据项14.clear 清空当前的vector15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)17.empty 判断vector是否为空18.swap 与另一个vector交换数据 三、基本用法#include &lt; vector&gt;using namespace std; 四、简单介绍 Vector&lt;类型&gt;标识符 Vector&lt;类型&gt;标识符(最大容量) Vector&lt;类型&gt;标识符(最大容量,初始所有值) Int i[5]={1,2,3,4,5}Vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值 Vector&lt; vector&lt; int&gt; &gt;v; 二维向量//这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过 实例来咯1.pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据12345678910111213141516171819202122232425262728#include &lt;string.h&gt; #include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt;obj(10,0);//最大容器为10，都初始化为0 for(int i=0;i&lt;10;i++)//push_back(elem)在数组最后添加数据 &#123; obj.push_back(i); cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; for(int i=0;i&lt;5;i++)//去掉数组最后一个数据 &#123; obj.pop_back(); &#125; cout&lt;&lt;&quot;\n&quot;&lt;&lt;endl; for(int i=0;i&lt;obj.size();i++)//size()容器中实际数据个数 &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; return 0;&#125; 2.clear()清除容器中所以数据12345678910111213141516171819202122#include &lt;string.h&gt; #include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt;obj; for(int i=0;i&lt;10;i++)//push_back(elem)在数组最后添加数据 &#123; obj.push_back(i); cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; obj.clear();//清除容器中所以数据 for(int i=0;i&lt;obj.size();i++) &#123; cout&lt;&lt;obj[i]&lt;&lt;endl; &#125; return 0;&#125; 3.排序1234567891011121314151617181920212223242526272829303132#include &lt;string.h&gt; #include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;int&gt;obj; obj.push_back(1); obj.push_back(3); obj.push_back(0); sort(obj.begin(),obj.end());//从小到大 cout&lt;&lt;&quot;从小到大:&quot;&lt;&lt;endl; for(int i=0;i&lt;obj.size();i++) &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; cout&lt;&lt;&quot;\n&quot;&lt;&lt;endl; cout&lt;&lt;&quot;从大到小:&quot;&lt;&lt;endl; reverse(obj.begin(),obj.end());//从大到小 for(int i=0;i&lt;obj.size();i++) &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; return 0;&#125; 1.注意sort需要头文件#include &lt; algorithm&gt;2.如果想sort来降序，可重写sortbool compare(int a,int b){return a&lt; b; //升序排列，如果改为return a&gt;b，则为降序}int a[20]={2,4,1,23,5,76,0,43,24,65},i;for(i=0;i&lt;20;i++)cout&lt;&lt; a[i]&lt;&lt; endl;sort(a,a+20,compare); 4.访问（直接数组访问&amp;迭代器访问）12345678910111213141516171819202122232425262728293031#include &lt;string.h&gt; #include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; //顺序访问 vector&lt;int&gt;obj; for(int i=0;i&lt;10;i++) &#123; obj.push_back(i); &#125; cout&lt;&lt;&quot;直接利用数组：&quot;; for(int i=0;i&lt;10;i++)//方法一 &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; cout&lt;&lt;&quot;利用迭代器：&quot; ; //方法二，使用迭代器将容器中数据输出 vector&lt;int&gt;::iterator it;//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 for(it=obj.begin();it!=obj.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 5.二维数组两种定义方法（结果一样）12345678910111213141516171819202122232425#include &lt;string.h&gt; #include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N=5, M=6; vector&lt;vector&lt;int&gt; &gt; obj(N); //定义二维动态数组大小5行 for(int i =0; i&lt; obj.size(); i++)//动态二维数组为5行6列，值全为0 &#123; obj[i].resize(M); &#125; for(int i=0; i&lt; obj.size(); i++)//输出二维动态数组 &#123; for(int j=0;j&lt;obj[i].size();j++) &#123; cout&lt;&lt;obj[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\n&quot;; &#125; return 0;&#125; 123456789101112131415161718192021#include &lt;string.h&gt; #include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N=5, M=6; vector&lt;vector&lt;int&gt; &gt; obj(N, vector&lt;int&gt;(M)); //定义二维动态数组5行6列 for(int i=0; i&lt; obj.size(); i++)//输出二维动态数组 &#123; for(int j=0;j&lt;obj[i].size();j++) &#123; cout&lt;&lt;obj[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\n&quot;; &#125; return 0;&#125;]]></content>
      <categories>
        <category>问题随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>问题解决</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm2037-今年暑假不AC]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm2037-%E4%BB%8A%E5%B9%B4%E6%9A%91%E5%81%87%E4%B8%8DAC%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description “今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…”&nbsp;确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）&nbsp;Input输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。&nbsp;Output对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。&nbsp;Sample Input12 1 3 3 4 0 7 3 8 15 19 15 20 10 15 8 18 6 12 5 10 4 14 2 9 0&nbsp;Sample Output5 二、Solution 贪心问题，按节目结束时间排序，当前节目的开始时间要晚于前一个节目的结束时间 三、Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * date:2017.11.16 * author:孟小德 * function:杭电acm2037 * 今年暑假不AC */import java.util.*;public class acm2037&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int num; while((num = input.nextInt()) != 0) &#123; int[][] gram = new int[num][2]; for (int i = 0;i&lt;num;i++) &#123; gram[i][0] = input.nextInt(); gram[i][1] = input.nextInt(); &#125; //排序 sort(gram); int count = 1; int end = gram[0][1]; for (int i=1;i&lt;num;i++) &#123; if (gram[i][0] &gt;= end) &#123; end = gram[i][1]; count++; &#125; &#125; System.out.println(count); &#125; &#125; //按节目结束时间由早到晚排序 public static void sort(int[][] gram) &#123; boolean flag = true; int[] temp = new int[2]; for (int i = 0;i&lt;gram.length &amp;&amp; flag;i++) &#123; flag = false; for (int j = 0;j&lt;gram.length-i-1;j++) &#123; if (gram[j][1] &gt; gram[j+1][1]) &#123; temp[0] = gram[j][0]; temp[1] = gram[j][1]; gram[j][0] = gram[j+1][0]; gram[j][1] = gram[j+1][1]; gram[j+1][0] = temp[0]; gram[j+1][1] = temp[1]; flag = true; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu-有什么奇技淫巧]]></title>
    <url>%2F2018%2F12%2F25%2F%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94%2FUbuntu-%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、 作者：xlzd链接：https://www.zhihu.com/question/27764060/answer/39459621来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1sudo apt-get install cmatrix 输入密码，安装后，按F11把terminal全屏，输入『cmatrix -b』，逼格瞬间暴增，最好旁边有个妹子。 二、1sudo apt-get install sl 安装后执行『sl』，怒看屏幕上一辆火车开过。 三、12sudo apt-get install figletsudo apt-get install toilet 试一下这两个小命令，生成艺术字figlet some texttoilet some other text还可以添加颜色，man一下具体用法吧 四、 xeyes屏幕出现一双眼睛，直到你按下【ctrl + c】强制结束。 yes输出无穷无尽的字符，如【yes xlzd】将一直输出【xlzd】 factor分解因数 fortune/输出一句笑话/名言/诗文等等]]></content>
      <categories>
        <category>问题随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>问题解决</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭电acm2544-最短路]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E6%9D%AD%E7%94%B5acm2544-%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、Problem Description 在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？&nbsp;Input输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。&nbsp;Output对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间&nbsp;Sample Input2 1 1 2 3 3 3 1 2 5 2 3 5 3 1 2 0 0&nbsp;Sample Output32 二、Solution 一个简单的最短路问题，用dijkstra,floyd等都可以解，我一开始用的是并查集但是出错了 三、Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package acm2544;/** * date:2017.12.18 * author:孟小德 * function:杭电acm2544 最短路 * 最小生成树，并查集 */import java.util.*;public class Main&#123; public static int MAXINT = 200000000; //最大长度表示无法联通 public static int NUM_OF_NODE; //城镇的数量 public static int NUM_OF_EDGE; //道路的数量 public static int[] PATH; //记录到每个城镇的最短路径 public static int[][] MAP; //一个二维数组记录城镇的道路情况 public static boolean[] S; public static void dijkstra(int v0) &#123; for (int i=1;i&lt;=NUM_OF_NODE;i++) &#123; PATH[i] = MAP[v0][i]; S[i] = false; &#125; PATH[v0] = 0; S[v0] = true; for (int i=2;i&lt;=NUM_OF_NODE;i++) &#123; int minpath = MAXINT; int u = v0; for (int j=1;j&lt;=NUM_OF_NODE;j++) &#123; if (S[j] == false &amp;&amp; PATH[j] &lt; minpath) &#123; u = j; minpath = PATH[j]; &#125; &#125; S[u] = true; //找到的当前点 // System.out.println(u); for (int j=1;j&lt;=NUM_OF_NODE;j++) &#123; if (S[j] == false &amp;&amp; MAP[u][j] &lt; MAXINT) &#123;//通过当前点u找到其他点到v0的最短路径 // System.out.println(&quot;#&quot;); // System.out.println(u + &quot; &quot; + j); // System.out.println(PATH[j]); // System.out.println(PATH[u] + &quot; &quot; + MAP[u][j]); if (PATH[u] + MAP[u][j] &lt; PATH[j]) &#123; PATH[j] = PATH[u] + MAP[u][j]; //更新最短路径 &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); NUM_OF_NODE = input.nextInt(); NUM_OF_EDGE = input.nextInt(); while (NUM_OF_NODE != 0 || NUM_OF_NODE != 0) &#123; MAP = new int[NUM_OF_NODE + 1][NUM_OF_NODE + 1]; PATH = new int[NUM_OF_NODE + 1]; S = new boolean[NUM_OF_NODE + 1]; for (int i=1;i&lt;=NUM_OF_NODE;i++) &#123; // PATH[i] = MAXINT; // S[i] = false; for (int j=1;j&lt;=NUM_OF_NODE;j++) &#123; MAP[i][j] = MAXINT; &#125; &#125; for (int i=0;i&lt;NUM_OF_EDGE;i++) &#123; int A = input.nextInt(); int B = input.nextInt(); int X = input.nextInt(); if (MAP[A][B] &gt; X) &#123; MAP[A][B] = X; MAP[B][A] = X; &#125; &#125; dijkstra(1); System.out.println(PATH[NUM_OF_NODE]); NUM_OF_NODE = input.nextInt(); NUM_OF_EDGE = input.nextInt(); &#125; input.close(); &#125;&#125;]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装QQ（for linux）]]></title>
    <url>%2F2018%2F12%2F25%2F%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94%2FUbuntu16-04%E5%AE%89%E8%A3%85QQ%EF%BC%88for-linux%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&nbsp; 一、安装1.安装wine1.1添加PPA1sudo add-apt-repository ppa:ubuntu-wine/ppa 1.2更新列表1sudo apt-get update 1.3安装Wine12sudo apt-get install wine1.8 winetricks (note :wine may need updata) 为了避免错误大家可以使用以下命令 1sudo apt-get update 2.下载wineQQhttp://www.ubuntukylin.com/application/show.php?lang=cn&amp;id=279&nbsp; 3.安装解压软件1$ sudo apt-get install unar 4.进入文件下载目录，解压并安装。123$ unar wine-qqintl.zip$ cd wine-qqintl 安装此目录下的所有文件 12345$ sudo dpkg -i fonts-wqy-microhei_0.2.0-beta-2_all.deb$ sudo dpkg -i ttf-wqy-microhei_0.2.0-beta-2_all.deb$ sudo dpkg -i wine-qqintl_0.1.3-2_i386.deb 5.在search your computer 输入QQ查找刚装载的QQ即可&nbsp; 二、问题与解决1.最后一个包安装有问题的话 1$ apt-get -f install]]></content>
      <categories>
        <category>问题随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>问题解决</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过交换相邻数来完成排序所需要的最少交换次数]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0%E6%9C%AC%2F%E9%80%9A%E8%BF%87%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E6%95%B0%E6%9D%A5%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&nbsp; 对一个无序序列进行排序，要求一次只能交换相邻的两个数，那么最少需要交换多少次才可以完成排序呢？本问题假设序列所有数各不相同。&nbsp; 一、概念介绍：&nbsp; 1、逆序 一般认为从左向右序列的数字增大认为是正序的，那么从左到右序列的序列数字出现减小就认为是逆序的。一个“逆序”的数学定义是这样的，如果存在正整数 i, j 使得 1 ≤ i &lt; j ≤ n 而且 A[i] &gt; A[j]，则 &lt;A[i], A[j]&gt; 这个有序对称为 A 的一个逆序，又称作一个逆序对。 2、逆序数 整个序列中的逆序对的个数叫做序列的逆序数。 3、逆序列 逆序列是表示序列逆序属性的一个序列，其定义是这样的，逆序列中的某一项aj表示原序列中的第二成分（左边成分）为j的逆序对的个数。逆序列中的j需要从小到大正序排列，这样子组成的序列就叫作逆序列。显然，逆序列各项之和也是序列的逆序数。 二、排序方法：1、方法 首先，根据待排序列，写出其逆序列。然后，根据逆序列中的每一项所代表的数j和逆序个数aj，将待排序列中对应的数j向左邻交换aj次。那么，交换完成后，序列就排序完成。此时，交换的次数就是最少的次数，也是原序列的逆序数。 2、具体例子： 原序列： 4 8 2 7 5 6 1 3逆序对有：(4,2), (4,1), (4, 3),(8,2), (8,7), (8,5), (8,6), (8,1), (8,3),(2,1),(7,5), (7,6), (7,1), (7,3),(5,1), (5,3),(6,1), (6,3),逆序数为18逆序列为：6 2 5 0 2 2 1 0&nbsp; 3、交换过程如下：12345678910111213141516171819202122232425 4 8 2 7 5 6 1 3 （1向左交换6次） 4 8 2 7 5 1 6 3 4 8 2 7 1 5 6 3 4 8 2 1 7 5 6 3 4 8 1 2 7 5 6 3 4 1 8 2 7 5 6 3 1 4 8 2 7 5 6 3 （2向左交换2次） 1 4 2 8 7 5 6 3 1 2 4 8 7 5 6 3 （3向左交换5次） 1 2 4 8 7 5 3 6 1 2 4 8 7 3 5 6 1 2 4 8 3 7 5 6 1 2 4 3 8 7 5 6 1 2 3 4 8 7 5 6 （5向左交换2次） 1 2 3 4 8 5 7 6 1 2 3 4 5 8 7 6 （6向左交换2次） 1 2 3 4 5 8 6 7 1 2 3 4 5 6 8 7 （7向左交换1次） 1 2 3 4 5 6 7 8 三、思考： 上面的过程，其实就是冒泡排序的过程，每一轮都能将最小的数冒到最左边。所区别的是，冒泡排序是直接两两比较、进行交换，而这里是先找逆序列，然后不比较、直接交换。两者在程序代码上的复杂度是差不多的。这里提供的一点是最少的交换次数-序列的逆序数。&nbsp;原文：http://blog.csdn.net/ojshilu/article/details/17066737]]></content>
      <categories>
        <category>程序日记本</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu删除多余内核]]></title>
    <url>%2F2018%2F12%2F25%2F%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94%2FUbuntu%E5%88%A0%E9%99%A4%E5%A4%9A%E4%BD%99%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[&nbsp; 第一：首先查询当前我们使用的是内核是那个版本别删错了。1uname -a 第二：查询系统中装了多少内核1dpkg --get-selections|grep linux 第三：多余的内核可以通过命令删除 需要删除header和image12sudo apt-get remove linux-image-*.*.*-**（*号用你想删除的实际情况改写）sudo apt-get remove linux-headers-*.*.*-**（*号用你想删除的实际情况改写） 第四：执行完上面命令后再次执行1dpkg --get-selections|grep linux 查看内核是否都删除干净了。没干净继续删除。有的内核后面会显示是deinstall 那需要通过 1dpkg --get-selections | grep deinstall | sed &apos;s/deinstall/\lpurge/&apos; | sudo dpkg --set-selections; sudo dpkg -Pa 通过上面方法就可以。还有一种通过正则表达式匹配内核然后除最新的统统统统删除的。 1dpkg -l &apos;linux-*&apos; | sed &apos;/^ii/!d;/&apos;&quot;$(uname -r | sed &quot;s/-/\1/&quot;)&quot;&apos;/d;s/^[^ ]* [^ ]* .*/\1/;/[0-9]/!d&apos; | xargs sudo apt-get -y purge]]></content>
      <categories>
        <category>问题随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>问题解决</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fedora-安装lantern]]></title>
    <url>%2F2018%2F12%2F25%2F%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94%2Ffedora-%E5%AE%89%E8%A3%85lantern%2F</url>
    <content type="text"><![CDATA[&nbsp; 第一步：添加源1dnf copr enable yelanxin/lantern 第二步：dnf安装1dnf install lantern]]></content>
      <categories>
        <category>问题随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>问题解决</tag>
        <tag>fedora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fedora删除多余不用的内核]]></title>
    <url>%2F2018%2F12%2F25%2F%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94%2Ffedora%E5%88%A0%E9%99%A4%E5%A4%9A%E4%BD%99%E4%B8%8D%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[&nbsp;原创 2012年07月06日 15:57:18 6523 1.查询安装的所有内核12345678910111213[root@localhost ~]# rpm -qa | grep kernelkernel-PAE-3.4.2-1.fc16.i686kernel-PAE-devel-3.4.2-1.fc16.i686kernel-PAE-devel-3.1.0-7.fc16.i686kernel-headers-3.4.2-1.fc16.i686abrt-addon-kerneloops-2.0.7-2.fc16.i686kernel-devel-3.3.2-6.fc16.i686kernel-PAE-3.3.5-2.fc16.i686kernel-PAE-devel-3.3.5-2.fc16.i686kernel-devel-3.4.2-1.fc16.i686kernel-devel-3.3.5-2.fc16.i686kernel-PAE-3.1.0-7.fc16.i686libreport-plugin-kerneloops-2.0.8-4.fc16.i686 我这里查出了很多个啊，看来fedora偷偷做了更新。 2.查询当前正在使用的内核12[root@localhost ~]# uname -r3.1.0-7.fc16.i686.PAE 我的是3.1.0的，因为在做开发，不想频繁更新内核，故把要把其它多余的都给干掉。 3.删除多余的内核1234567[root@localhost ~]# yum remove kernel-PAE-3.4.2*[root@localhost ~]# yum remove kernel-PAE-devel-3.4.2*[root@localhost ~]# yum remove kernel-devel-3.4.2*[root@localhost ~]# yum remove kernel-devel-3.3.2* 删除即可。 4.重启计算机1[root@localhost ~]# reboot 转载自：http://blog.csdn.net/charlsecharlse/article/details/7722478]]></content>
      <categories>
        <category>问题随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>问题解决</tag>
        <tag>fedora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux和windows中命令行编译qt程序步骤]]></title>
    <url>%2F2018%2F12%2F25%2F%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94%2Flinux%E5%92%8Cwindows%E4%B8%AD%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91qt%E7%A8%8B%E5%BA%8F%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[&nbsp; linux平台命令行编译1.检查一下qmake版本（可省略）qmake -v which qmake2.具体步骤以/home/michael/program_reference/hello.cpp工程为例， 代码如下： 1234567891011121314151. `#include &lt;QApplication&gt;`2. `#include &lt;QLabel&gt;`3. `#include &lt;QtDebug&gt;`5. `int main(int argc,char* argv[])`6. `&#123;`7. `QApplication a(argc,argv);`9. `QLabel label(&quot;hello&quot;);`10. `label.show();`12. `qDebug()&lt;&lt;&quot;hell mq&quot;;`14. `return a.exec();`15. `&#125;` 编译过程如下： 2.1.在 hello.cpp所在目录下，运行命令：qmake -projecthello.cpp 同目录下有hello.pro文件被生成，它是与平台无关的工程文件。 注：此处因为版本QT4和QT5的原因，需要修改hello.pro文件，具体修改内容如下：在.pro文件中加入以下代码： QT += widgets core gui 2.2. 在 hello.cpp所在目录下，运行命令：qmake hello.pro同目录下有 Makefile文件被生成（Makefile是指导编译器编译源代码的配置文件，在其目录下输入make命令(nmake在win32,vc6环境)就可以完成编译）。 2.3.在 hello.cpp所在目录下，运行命令：make同目录下有 hello,hello.o两个文件被编译生成。其中 hello就是在当前 Linux 系统下使用 Qt编译生成的可执行文件了。来源： http://blog.csdn.net/imxiangzi/article/details/7454276 windows平台命令行编译注：此方法未经本人证实 1、打开环境变量设置窗口，编辑 PATH 变量，添加如下内容：c:/Qt/2010.02.1/bin/; c:/Qt/2010.02.1/qt/bin/; c:/Qt/2010.02.1/mingw/bin/ 2、打开环境变量设置窗口，添加环境变量QTDIR：变量名：QTDIR 变量值：C:/Qt/2010.02.1/qt 3、打开环境变量设置窗口，添加环境变量QMAKESPEC：变量名：QMAKESPEC 变量值：win32-g++ 4、现在已经可以进行命令行模式的编译了，例如：a、建立一个空文件夹 hello，然后在其中建立一个空文件 hello.cpp，编辑并保存此文件。 #include QApplication&gt; #include QPushButton&gt; int main(int argc,char* argv[]) { QApplication app(argc,argv); QPushButton * bt = new QPushButton(&quot;quit&quot;); QObject::connect(bt,SIGNAL(clicked()),&amp;app,SLOT(exit())); bt-&gt;show(); return app.exec(); } b、在hello目录下，命令行输入运行 qmake -project，生成 hello.pro c、在hello目录下，命令行输入运行 qmake hello.pro，生成了 makefile d、在hello目录下，命令行输入运行 mingw32-make，生成了 hello.exe（位于 Debug 目录下） e、进入 Debug 目录，执行 hello.exe转载自：https://www.cnblogs.com/xiahaimq/p/6269429.html]]></content>
      <categories>
        <category>问题随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>问题解决</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MiHo-主题安装和配置详情]]></title>
    <url>%2F2018%2F12%2F24%2F%E9%97%AE%E9%A2%98%E9%9A%8F%E7%AC%94%2Finstallation-configuration%2F</url>
    <content type="text"><![CDATA[​​ 一. 主题简介&emsp;&emsp;MiHo 是一款单栏响应式的Hexo主题；基于 Hexo 3.0+ 制作，兼容移动端浏览；主题的代码托管在GitHub上，欢迎Star和Fork；如遇到问题或发表建议，可以提Issues，也可以在博客中留言给我，另外,喜欢的话不妨给个 Star。 二. 安装2.1 安装主题1$ git clone https://github.com/WongMinHo/hexo-theme-miho.git themes/miho MiHo 主题需要Hexo 3.0或以上版本，请先升级。 2.2 更新12cd themes/mihogit pull 2.3 依赖安装如下依赖如果已经安装，请看配置介绍。 Json-content生成站点文章静态数据，用于站内搜索。 1npm install hexo-generator-json-content --save 三. 站点配置站点配置文件_config.yml在hexo根目录下。 3.1 启用主题1`theme: miho` 3.2 网站基本配置以下配置是站点的全局配置，更多配置，请查看 123456title: MinHow's Blogsubtitle: 网站副标题description: 专注 WEB 开发的技术博客author: MinHowlanguage: 网站使用的语言timezone: 网站时区 3.3 jsonContent配置详细的配置请查看hexo-generator-json-content 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false 四. 主题配置编辑主题配置文件，themes/miho/_config.yml。 4.1 属性下面将介绍几个比较重要的配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122# hexo-theme-miho# https://github.com/wongminho/hexo-theme-miho# Favicon of your site | 网站iconfavicon: /favicon.ico# Header# Keywords of your site | 网站关键字keywords: MinHow,MinHow's Blog# Head headline | 头部标题header_title: MinHow's Blog# Head description | 头部描述header_description: 一个专注 WEB 开发的技术博客# Link to your logo | logo地址logo: images/logo.png# Link to your banner_img | 首页banner图地址banner_img: images/banner.jpg# Menu setting | 菜单设置# name: Font Awesome icon | Font Awesome 图标# title: Home Title | 标题# url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出menu: home: title: Home url: / target: false archive: title: Archives url: /archives target: false user: title: About url: /about target: false# Social setting, use to display social information | 社交设置，用来展示社交信息# name: Font Awesome icon | Font Awesome 图标# title: Home Icon title | 图标标题# url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出social: home: title: MinHow url: //minhow.com target: true github: title: Github url: //github.com/wongminho target: true weibo: title: Weibo url: //weibo.com/WongMinHo target: true twitter: title: Twitter url: //twitter.com/huangminhow target: true #qq: #weixin: #snapchat: #telegram: #mail: #facebook: #google: #linkedin:# Content# Excerpt length | 摘录长度excerpt_length: 190# Excerpt link | 摘录链接excerpt_link: more&gt;&gt;# New window open link | 新窗口打开文章open_new_link: false# Article default cover picture，size：350*150 | 文章默认封面图，尺寸：350*150cover_picture: images/banner.jpg# Open background particles | 开启背景粒子open_bg_particle: true# Open animation in homepage and head | 开启主页及头部动画open_animation: true# Article# Open toc | 是否开启toctoc: true# Open share | 是否开启分享share: true# Style customization | 样式定制style: # Main color tone | 主色调 main_color: '#0cc'# Comments | 评论# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false# Analytics | 分析# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google analytics | google分析google_analytics: false# Footer# Access statistics | “不蒜子”访问量统计access_counter: on: true site_uv: 总访客数： site_pv: 总访问量：# Copyright Information | 版权信息copyright: 2017 MinHow 4.2 文章封面图文章默认封面图，尺寸：350*150，当文章基本配置没有cover_picture时才显示。 1cover_picture: images/banner.jpg 4.3 开启背景粒子是否开启背景粒子。 1open_bg_particle: true 4.4 开启主页及头部动画是否开启主页及头部动画。 1open_animation: true 4.5 评论支持畅言、disqus。 1234567# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false 4.6 数据统计支持站长、百度、google三种数据统计，正确填写配置信息即可。 123456# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google分析google_analytics: false 4.7 文章基本配置123456789101112---title: Hello Worlddate: 2017-06-18categories: Firstauthor: MinHowtags: - First - Secondcover_picture: /images/banner.jpg--- MinHow-This is a summary&lt;!-- more --&gt; 说明： 需要注意tags和摘要的写法，不然首页不能正确显示标签和摘要； cover_picture文章封面图，不填默认显示_config.yml配置的图片。]]></content>
      <categories>
        <category>问题随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>问题解决</tag>
      </tags>
  </entry>
</search>
